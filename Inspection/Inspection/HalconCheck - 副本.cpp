///////////////////////////////////////////////////////////////////////////////
//  File generated by HDevelop for HALCON/C++ Version 12.0
///////////////////////////////////////////////////////////////////////////////



#ifndef __APPLE__
#  include "HalconCpp.h"
#  include "HDevThread.h"
#else
#  ifndef HC_LARGE_IMAGES
#    include <HALCONCpp/HalconCpp.h>
#    include <HALCONCpp/HDevThread.h>
#  else
#    include <HALCONCppxl/HalconCpp.h>
#    include <HALCONCppxl/HDevThread.h>
#  endif
#endif
#include "HCPPdl_ConfigIni.h"



using namespace HalconCpp;

HTuple  G_DEEP_REGION;
HTuple  G_SHALLOW_REGION;
HTuple  G_DEEP_REGION2;
HTuple  G_SHALLOW_REGION2;
HTuple  G_AREA_MAX;
HTuple  g_filemappingMax;
HTuple  g_OCRSignsIndexModel;
HTuple ExpGetGlobalVar_G_DEEP_REGION(void)
{
  return G_DEEP_REGION;
}
void ExpSetGlobalVar_G_DEEP_REGION(HTuple val)
{
  G_DEEP_REGION = val;
}

HTuple ExpGetGlobalVar_G_SHALLOW_REGION(void)
{
  return G_SHALLOW_REGION;
}
void ExpSetGlobalVar_G_SHALLOW_REGION(HTuple val)
{
  G_SHALLOW_REGION = val;
}

HTuple ExpGetGlobalVar_G_DEEP_REGION2(void)
{
  return G_DEEP_REGION2;
}
void ExpSetGlobalVar_G_DEEP_REGION2(HTuple val)
{
  G_DEEP_REGION2 = val;
}

HTuple ExpGetGlobalVar_G_SHALLOW_REGION2(void)
{
  return G_SHALLOW_REGION2;
}
void ExpSetGlobalVar_G_SHALLOW_REGION2(HTuple val)
{
  G_SHALLOW_REGION2 = val;
}

HTuple ExpGetGlobalVar_G_AREA_MAX(void)
{
  return G_AREA_MAX;
}
void ExpSetGlobalVar_G_AREA_MAX(HTuple val)
{
  G_AREA_MAX = val;
}

HTuple ExpGetGlobalVar_g_filemappingMax(void)
{
  return g_filemappingMax;
}
void ExpSetGlobalVar_g_filemappingMax(HTuple val)
{
  g_filemappingMax = val;
}

HTuple ExpGetGlobalVar_g_OCRSignsIndexModel(void)
{
  return g_OCRSignsIndexModel;
}
void ExpSetGlobalVar_g_OCRSignsIndexModel(HTuple val)
{
  g_OCRSignsIndexModel = val;
}

// Procedure declarations 
// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box);
// Chapter: File
// Short Description: Parse a filename into directory, base filename, and extension 
void parse_filename (HTuple hv_FileName, HTuple *hv_BaseName, HTuple *hv_Extension, 
    HTuple *hv_Directory);
void CloseCheck (HTuple hv_MessageInHandle);
void MainTest (HTuple hv_TestName, HTuple hv_IsTain, HTuple hv_ImageW, HTuple hv_ImageH, 
    HTuple hv_CameraIndex, HTuple hv_ImagePath);
void load_config (HTuple hv_ParamSettingsFile, HTuple hv_section, HTuple hv_key, 
    HTuple hv_Defaultval, HTuple *hv_val);
void create_nodes (HTuple hv_Nodes, HTuple *hv_Path);
void InitCheck (HTuple hv_TestName, HTuple hv_CameraIndex, HTuple hv_ImageW, HTuple hv_ImageH, 
    HTuple *hv_MessageHandle);
void TrainNewModel (HTuple hv_MessageHandle, HTuple hv_WindowHandle, HTuple hv_ClassNames, 
    HTuple hv_ImagePaths);
void SaveImage (HObject ho_Image, HTuple hv_filename);
void downCheck (HObject ho_Image, HTuple hv_ShowHide, HTuple hv_WindowHandle, HTuple hv_MessageHandle, 
    HTuple hv_OutMessageHandle, HTuple *hv_Error_info, HTuple *hv_Info);
void getallmessage (HTuple hv_MessageHandle);
void GetResult (HTuple hv_Resultstrs, HTuple *hv_ResultName, HTuple *hv_Resultstrs2);
void gen_region_byTypeAndStr (HObject *ho_Region, HTuple hv_Type, HTuple hv_str, 
    HTuple *hv_Vals);
void TrainTestSvm (HTuple hv_ShowHide, HTuple hv_WindowHandle, HTuple hv_MessageHandle, 
    HTuple hv_OutMessageHandle);
void Show_Hide (HObject ho_obj, HTuple hv_ShowHide, HTuple hv_WindowHandle);
void HCheck (HObject ho_Image, HObject *ho_PreprocessImage, HTuple hv_IndexSN, HTuple hv_ShowHide, 
    HTuple hv_WindowHandle, HTuple hv_MessageHandle, HTuple *hv_ResultInfo, HTuple *hv_WindowInfo, 
    HTupleVector/*{eTupleVector,Dim=2}*/ *hvec_FeatureVals);
void get_param_by_drawID (HTuple hv_DrawID, HTuple *hv_ParamType, HTuple *hv_Paramstr, 
    HTuple *hv_ParamNote, HTuple *hv_ParamData);
void CalculateFeatures (HObject ho_InputRegion, HObject ho_Image, HObject ho_DynThreshRegion1, 
    HObject ho_DynThreshRegion2, HObject ho_DynThreshRegion3, HObject ho_DynThreshRegion4, 
    HTuple hv_ProdR1, HTuple hv_ProdR2, HTuple hv_ProdC1, HTuple hv_ProdC2, HTuple hv_MessageHandle, 
    HTupleVector/*{eTupleVector,Dim=1}*/ *hvec_FeatureVals);
void Check_Surface (HObject ho_Image, HTuple hv_ShowHide, HTuple hv_WindowHandle, 
    HTuple hv_MessageHandle, HTuple *hv_ResultInfo, HTuple *hv_WindowInfo, HTupleVector/*{eTupleVector,Dim=2}*/ *hvec_FeatureVals);
void GetRemainRegion (HObject ho_RegionInput, HObject ho_RegionReduced, HObject ho_AlreadySeg, 
    HObject ho_ProductRegion, HObject ho_DynThreshRegion, HObject *ho_RegionInputOut, 
    HObject *ho_AlreadySegOut, HObject *ho_RegionReducedOut, HObject *ho_DynThreshRegionOut);
void InitSurCheck (HTuple hv_MessageHandle);
void load_config_keys_vals (HTuple hv_IniFile, HTuple hv_SectionName, HTuple *hv_KeyNames, 
    HTuple *hv_KeyVals);
void Check_OCR (HObject ho_Image, HTuple hv_ShowHide, HTuple hv_WindowHandle, HTuple hv_MessageHandle, 
    HTuple *hv_ResultInfo, HTuple *hv_WindowInfo, HTupleVector/*{eTupleVector,Dim=2}*/ *hvec_FeatureVals);
void MessageExit (HTuple hv_MessageHandle, HTuple hv_MessageKey, HTuple hv_SetVal, 
    HTuple *hv_IsExit);
void tuple_regexp_replace_all (HTuple hv_Data, HTuple hv_Expression, HTuple hv_Replace, 
    HTuple *hv_DataOut);
void Init_FloorCheck (HTuple hv_CurrentScheme, HTuple hv_CheckParam, HTuple hv_MessageHandle);
void loglog (HTuple hv_MessageInHandle, HTuple hv_NewCreate, HTuple hv_logtxt);
void get_message_tuple_romove (HTuple hv_MessageHandle, HTuple hv_Key, HTuple *hv_TupleData);
void load_config_ValByType (HTuple hv_FileName, HTuple hv_Section, HTuple hv_KeyName, 
    HTuple hv_KeyType, HTuple hv_Defaultval, HTuple *hv_OutData);
void load_config_number (HTuple hv_ParamSettingsFile, HTuple hv_section, HTuple hv_key, 
    HTuple hv_Defaultval, HTuple *hv_val);
void UpFaceCheck (HObject ho_Image, HTuple hv_MessageHandle, HTuple hv_WindowHandle, 
    HTuple *hv_Features, HTuple *hv_IsTrue);
void create_object_drawID (HTuple hv_str, HTuple *hv_DrawID);
void Set_DefaultVal_To_ini (HTuple hv_FileName, HTuple hv_Section, HTuple hv_KeyName, 
    HTuple hv_Defaultval);
void DreiFeatureExtract (HObject ho_Image, HTuple hv_WindowHandle, HTuple *hv_Feature);
void PreprocessImage (HObject ho_Image, HObject *ho_PreprocessImage, HTuple hv_MessageHandle);
void load_config_set_message_Number (HTuple hv_MessageHandle, HTuple hv_ParamSettingsFile, 
    HTuple hv_section, HTuple hv_Inikey, HTuple hv_MessageKey, HTuple hv_Defaultval, 
    HTuple *hv_val);
void gen_region_by_str (HObject *ho_Region, HTuple hv_str, HTuple *hv_Type);
void Check_DownSur (HObject ho_Image, HTuple hv_ShowHide, HTuple hv_WindowHandle, 
    HTuple hv_MessageHandle, HTuple *hv_ResultInfo, HTuple *hv_WindowInfo, HTupleVector/*{eTupleVector,Dim=2}*/ *hvec_FeatureVals);
void Py_Memory_Check (HObject ho_Image, HObject *ho_ImageResult, HTuple hv_MessageHandle, 
    HTuple hv_WindowHandle, HTuple hv_ShowHide, HTuple hv_Width, HTuple hv_Height, 
    HTuple hv_ImageInfos, HTuple *hv_ResultVal);
void Check_Floor (HObject ho_Image, HTuple hv_ShowHide, HTuple hv_WindowHandle, HTuple hv_MessageHandle, 
    HTuple *hv_ResultInfo, HTuple *hv_WindowInfo, HTupleVector/*{eTupleVector,Dim=2}*/ *hvec_FeatureVals);
void GetPyFeature (HObject ho_ImageResult, HTuple hv_MessageHandle, HTuple hv_ShowHide, 
    HTuple hv_WindowHandle, HTuple hv_PyResultVal, HTuple *hv_ResultInfo, HTuple *hv_WindowInfo, 
    HTupleVector/*{eTupleVector,Dim=2}*/ *hvec_FeatureVals);
void Init_TopSurfaceDetection (HTuple hv_CurrentScheme, HTuple hv_lsCheckParam, HTuple hv_MessageHandle);
void Init_Python_Memory (HTuple hv_TestPlanIni, HTuple hv_CheckParam, HTuple hv_MessageHandle);
void IniMapFile (HTuple hv_FileNames, HTuple hv_Filesizes, HTuple *hv_Filehandles);
void Init_SideMeasurementDetection (HTuple hv_CurrentScheme, HTuple hv_CheckParam, 
    HTuple hv_MessageHandle);
void Check_Side (HObject ho_Image, HTuple hv_ShowHide, HTuple hv_WindowHandle, HTuple hv_MessageHandle, 
    HTuple *hv_ResultInfo, HTuple *hv_WindowInfo, HTupleVector/*{eTupleVector,Dim=2}*/ *hvec_FeatureVals);
void Init_OCRFlawDetection (HTuple hv_CurrentScheme, HTuple hv_CheckParam, HTuple hv_DirPath, 
    HTuple hv_MessageHandle);
void Check_Sur (HObject ho_PreprocessImage, HTuple hv_ShowHide, HTuple hv_WindowHandle, 
    HTuple hv_MessageHandle, HTuple *hv_ResultInfo, HTuple *hv_WindowInfo, HTupleVector/*{eTupleVector,Dim=2}*/ *hvec_FeatureVals);
void Init_BottomSurfaceDetection (HTuple hv_CurrentScheme, HTuple hv_CheckParam, 
    HTuple hv_MessageHandle);
void InitGlobalOnce ();
void SaveImageThread (HObject ho_Image, HTuple hv_Format, HTuple hv_fillcolor, HTuple hv_filename);
void Init_BottomConvexDetection (HTuple hv_CurrentScheme, HTuple hv_lsCheckParam, 
    HTuple hv_MessageHandle);
void Check_EinsFeatureExtract (HObject ho_Image, HTuple hv_ShowHide, HTuple hv_WindowHandle, 
    HTuple hv_MessageHandle, HTuple *hv_ResultInfo, HTuple *hv_WindowInfo, HTupleVector/*{eTupleVector,Dim=2}*/ *hvec_FeatureVals);
void load_config_set_message_Str (HTuple hv_MessageHandle, HTuple hv_ParamSettingsFile, 
    HTuple hv_section, HTuple hv_Inikey, HTuple hv_MessageKey, HTuple hv_Defaultval, 
    HTuple *hv_val);
void OCR_Find (HObject ho_ImageReduced, HObject ho_Image, HTuple hv_ShowHide, HTuple hv_WindowHandle, 
    HTuple hv_MessageHandle, HTuple hv_OCRSign, HTuple hv_Width, HTuple hv_Height, 
    HTuple *hv_isFindOCR, HTuple *hv_WindowInfo);
void GetOCRChrs (HObject ho_TmpObj_Mono, HObject ho_ROI_OCR_uF, HTuple hv_TextModel, 
    HTuple hv_OcrHandle, HTuple *hv_OCRChrs, HTuple *hv_OCRChrsConfidences);
void load_config_split (HTuple hv_inifile, HTuple hv_Section, HTuple hv_keyname, 
    HTuple hv_defaultval, HTuple hv_splitstr, HTuple *hv_val);
void load_config_split_numeber (HTuple hv_inifile, HTuple hv_Section, HTuple hv_keyname, 
    HTuple hv_defaultval, HTuple hv_splitstr, HTuple *hv_val);
// Generated stubs for parallel procedure calls. Wrapped in name
// space to avoid name conflicts with actual procedure names
namespace HDevExportCpp
{
// Parallel execution wrapper for Py_Memory_Check(...) 
static void* _hcppthread_Py_Memory_Check(void *hcthread);
// Parallel execution wrapper for write_image(...) 
static void* _hcppthread_write_image(void *hcthread);
}

// Procedures 
// Chapter: Graphics / Text
// Short Description: This procedure writes a text message. 
void disp_message (HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem, 
    HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Red, hv_Green, hv_Blue, hv_Row1Part;
  HTuple  hv_Column1Part, hv_Row2Part, hv_Column2Part, hv_RowWin;
  HTuple  hv_ColumnWin, hv_WidthWin, hv_HeightWin, hv_MaxAscent;
  HTuple  hv_MaxDescent, hv_MaxWidth, hv_MaxHeight, hv_R1;
  HTuple  hv_C1, hv_FactorRow, hv_FactorColumn, hv_UseShadow;
  HTuple  hv_ShadowColor, hv_Exception, hv_Width, hv_Index;
  HTuple  hv_Ascent, hv_Descent, hv_W, hv_H, hv_FrameHeight;
  HTuple  hv_FrameWidth, hv_R2, hv_C2, hv_DrawMode, hv_CurrentColor;

  //This procedure displays text in a graphics window.
  //
  //Input parameters:
  //WindowHandle: The WindowHandle of the graphics window, where
  //   the message should be displayed
  //String: A tuple of strings containing the text message to be displayed
  //CoordSystem: If set to 'window', the text position is given
  //   with respect to the window coordinate system.
  //   If set to 'image', image coordinates are used.
  //   (This may be useful in zoomed images.)
  //Row: The row coordinate of the desired text position
  //   If set to -1, a default value of 12 is used.
  //Column: The column coordinate of the desired text position
  //   If set to -1, a default value of 12 is used.
  //Color: defines the color of the text as string.
  //   If set to [], '' or 'auto' the currently set color is used.
  //   If a tuple of strings is passed, the colors are used cyclically
  //   for each new textline.
  //Box: If Box[0] is set to 'true', the text is written within an orange box.
  //     If set to' false', no box is displayed.
  //     If set to a color string (e.g. 'white', '#FF00CC', etc.),
  //       the text is written in a box of that color.
  //     An optional second value for Box (Box[1]) controls if a shadow is displayed:
  //       'true' -> display a shadow in a default color
  //       'false' -> display no shadow (same as if no second value is given)
  //       otherwise -> use given string as color string for the shadow color
  //
  //Prepare window
  GetRgb(hv_WindowHandle, &hv_Red, &hv_Green, &hv_Blue);
  GetPart(hv_WindowHandle, &hv_Row1Part, &hv_Column1Part, &hv_Row2Part, &hv_Column2Part);
  GetWindowExtents(hv_WindowHandle, &hv_RowWin, &hv_ColumnWin, &hv_WidthWin, &hv_HeightWin);
  SetPart(hv_WindowHandle, 0, 0, hv_HeightWin-1, hv_WidthWin-1);
  //
  //default settings
  if (0 != (hv_Row==-1))
  {
    hv_Row = 12;
  }
  if (0 != (hv_Column==-1))
  {
    hv_Column = 12;
  }
  if (0 != (hv_Color==HTuple()))
  {
    hv_Color = "";
  }
  //
  hv_String = ((""+hv_String)+"").TupleSplit("\n");
  //
  //Estimate extentions of text depending on font size.
  GetFontExtents(hv_WindowHandle, &hv_MaxAscent, &hv_MaxDescent, &hv_MaxWidth, &hv_MaxHeight);
  if (0 != (hv_CoordSystem==HTuple("window")))
  {
    hv_R1 = hv_Row;
    hv_C1 = hv_Column;
  }
  else
  {
    //Transform image to window coordinates
    hv_FactorRow = (1.*hv_HeightWin)/((hv_Row2Part-hv_Row1Part)+1);
    hv_FactorColumn = (1.*hv_WidthWin)/((hv_Column2Part-hv_Column1Part)+1);
    hv_R1 = ((hv_Row-hv_Row1Part)+0.5)*hv_FactorRow;
    hv_C1 = ((hv_Column-hv_Column1Part)+0.5)*hv_FactorColumn;
  }
  //
  //Display text box depending on text size
  hv_UseShadow = 1;
  hv_ShadowColor = "gray";
  if (0 != (HTuple(hv_Box[0])==HTuple("true")))
  {
    hv_Box[0] = "#fce9d4";
    hv_ShadowColor = "#f28d26";
  }
  if (0 != ((hv_Box.TupleLength())>1))
  {
    if (0 != (HTuple(hv_Box[1])==HTuple("true")))
    {
      //Use default ShadowColor set above
    }
    else if (0 != (HTuple(hv_Box[1])==HTuple("false")))
    {
      hv_UseShadow = 0;
    }
    else
    {
      hv_ShadowColor = ((const HTuple&)hv_Box)[1];
      //Valid color?
      try
      {
        SetColor(hv_WindowHandle, HTuple(hv_Box[1]));
      }
      // catch (Exception) 
      catch (HalconCpp::HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
        hv_Exception = "Wrong value of control parameter Box[1] (must be a 'true', 'false', or a valid color string)";
        throw HalconCpp::HException(hv_Exception);
      }
    }
  }
  if (0 != (HTuple(hv_Box[0])!=HTuple("false")))
  {
    //Valid color?
    try
    {
      SetColor(hv_WindowHandle, HTuple(hv_Box[0]));
    }
    // catch (Exception) 
    catch (HalconCpp::HException &HDevExpDefaultException)
    {
      HDevExpDefaultException.ToHTuple(&hv_Exception);
      hv_Exception = "Wrong value of control parameter Box[0] (must be a 'true', 'false', or a valid color string)";
      throw HalconCpp::HException(hv_Exception);
    }
    //Calculate box extents
    hv_String = (" "+hv_String)+" ";
    hv_Width = HTuple();
    {
    HTuple end_val93 = (hv_String.TupleLength())-1;
    HTuple step_val93 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val93, step_val93); hv_Index += step_val93)
    {
      GetStringExtents(hv_WindowHandle, HTuple(hv_String[hv_Index]), &hv_Ascent, 
          &hv_Descent, &hv_W, &hv_H);
      hv_Width = hv_Width.TupleConcat(hv_W);
    }
    }
    hv_FrameHeight = hv_MaxHeight*(hv_String.TupleLength());
    hv_FrameWidth = (HTuple(0).TupleConcat(hv_Width)).TupleMax();
    hv_R2 = hv_R1+hv_FrameHeight;
    hv_C2 = hv_C1+hv_FrameWidth;
    //Display rectangles
    GetDraw(hv_WindowHandle, &hv_DrawMode);
    SetDraw(hv_WindowHandle, "fill");
    //Set shadow color
    SetColor(hv_WindowHandle, hv_ShadowColor);
    if (0 != hv_UseShadow)
    {
      DispRectangle1(hv_WindowHandle, hv_R1+1, hv_C1+1, hv_R2+1, hv_C2+1);
    }
    //Set box color
    SetColor(hv_WindowHandle, HTuple(hv_Box[0]));
    DispRectangle1(hv_WindowHandle, hv_R1, hv_C1, hv_R2, hv_C2);
    SetDraw(hv_WindowHandle, hv_DrawMode);
  }
  //Write text.
  {
  HTuple end_val115 = (hv_String.TupleLength())-1;
  HTuple step_val115 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val115, step_val115); hv_Index += step_val115)
  {
    hv_CurrentColor = ((const HTuple&)hv_Color)[hv_Index%(hv_Color.TupleLength())];
    if (0 != (HTuple(hv_CurrentColor!=HTuple("")).TupleAnd(hv_CurrentColor!=HTuple("auto"))))
    {
      SetColor(hv_WindowHandle, hv_CurrentColor);
    }
    else
    {
      SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
    }
    hv_Row = hv_R1+(hv_MaxHeight*hv_Index);
    SetTposition(hv_WindowHandle, hv_Row, hv_C1);
    WriteString(hv_WindowHandle, HTuple(hv_String[hv_Index]));
  }
  }
  //Reset changed window settings
  SetRgb(hv_WindowHandle, hv_Red, hv_Green, hv_Blue);
  SetPart(hv_WindowHandle, hv_Row1Part, hv_Column1Part, hv_Row2Part, hv_Column2Part);
  return;
}

// Chapter: File
// Short Description: Parse a filename into directory, base filename, and extension 
void parse_filename (HTuple hv_FileName, HTuple *hv_BaseName, HTuple *hv_Extension, 
    HTuple *hv_Directory)
{

  // Local control variables
  HTuple  hv_DirectoryTmp, hv_Substring;

  //This procedure gets a filename (with full path) as input
  //and returns the directory path, the base filename and the extension
  //in three different strings.
  //
  //In the output path the path separators will be replaced
  //by '/' in all cases.
  //
  //The procedure shows the possibilities of regular expressions in HALCON.
  //
  //Input parameters:
  //FileName: The input filename
  //
  //Output parameters:
  //BaseName: The filename without directory description and file extension
  //Extension: The file extension
  //Directory: The directory path
  //
  //Example:
  //basename('C:/images/part_01.png',...) returns
  //BaseName = 'part_01'
  //Extension = 'png'
  //Directory = 'C:\\images\\' (on Windows systems)
  //
  //Explanation of the regular expressions:
  //
  //'([^\\\\/]*?)(?:\\.[^.]*)?$':
  //To start at the end, the '$' matches the end of the string,
  //so it is best to read the expression from right to left.
  //The part in brackets (?:\\.[^.}*) denotes a non-capturing group.
  //That means, that this part is matched, but not captured
  //in contrast to the first bracketed group ([^\\\\/], see below.)
  //\\.[^.]* matches a dot '.' followed by as many non-dots as possible.
  //So (?:\\.[^.]*)? matches the file extension, if any.
  //The '?' at the end assures, that even if no extension exists,
  //a correct match is returned.
  //The first part in brackets ([^\\\\/]*?) is a capture group,
  //which means, that if a match is found, only the part in
  //brackets is returned as a result.
  //Because both HDevelop strings and regular expressions need a '\\'
  //to describe a backslash, inside regular expressions within HDevelop
  //a backslash has to be written as '\\\\'.
  //[^\\\\/] matches any character but a slash or backslash ('\\' in HDevelop)
  //[^\\\\/]*? matches a string od 0..n characters (except '/' or '\\')
  //where the '?' after the '*' switches the greediness off,
  //that means, that the shortest possible match is returned.
  //This option is necessary to cut off the extension
  //but only if (?:\\.[^.]*)? is able to match one.
  //To summarize, the regular expression matches that part of
  //the input string, that follows after the last '/' or '\\' and
  //cuts off the extension (if any) after the last '.'.
  //
  //'\\.([^.]*)$':
  //This matches everything after the last '.' of the input string.
  //Because ([^.]) is a capturing group,
  //only the part after the dot is returned.
  //
  //'.*[\\\\/]':
  //This matches the longest substring with a '/' or a '\\' at the end.
  //
  TupleRegexpMatch(hv_FileName, ".*[\\\\/]", &hv_DirectoryTmp);
  TupleSubstr(hv_FileName, hv_DirectoryTmp.TupleStrlen(), (hv_FileName.TupleStrlen())-1, 
      &hv_Substring);
  TupleRegexpMatch(hv_Substring, "([^\\\\/]*?)(?:\\.[^.]*)?$", &(*hv_BaseName));
  TupleRegexpMatch(hv_Substring, "\\.([^.]*)$", &(*hv_Extension));
  //
  //
  //Finally all found backslashes ('\\') are converted
  //to a slash to get consistent paths
  TupleRegexpReplace(hv_DirectoryTmp, (HTuple("\\\\").Append("replace_all")), "/", 
      &(*hv_Directory));
  return;
}

void CloseCheck (HTuple hv_MessageInHandle)
{

  // Local control variables
  HTuple  hv_message_keys, hv_Selection, hv_Index;
  HTuple  hv_Selection2, hv_key_exist, hv_TupleData, hv_TupleData1;

  //
  //
  GetMessageParam(hv_MessageInHandle, "message_keys", HTuple(), &hv_message_keys);
  TupleRegexpSelect(hv_message_keys, "_CloseClear", &hv_Selection);
  //
  {
  HTuple end_val5 = (hv_Selection.TupleLength())-1;
  HTuple step_val5 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val5, step_val5); hv_Index += step_val5)
  {
    TupleRegexpReplace(HTuple(hv_Selection[hv_Index]), "_CloseClear", "", &hv_Selection2);
    GetMessageParam(hv_MessageInHandle, "key_exists", hv_Selection2, &hv_key_exist);
    if (0 != (hv_key_exist==1))
    {
      GetMessageTuple(hv_MessageInHandle, HTuple(hv_Selection[hv_Index]), &hv_TupleData);
      if (0 != (hv_TupleData==HTuple("clear_deformable_model")))
      {
        GetMessageTuple(hv_MessageInHandle, hv_Selection2, &hv_TupleData1);
        ClearDeformableModel(hv_TupleData1);
      }
      else if (0 != (hv_TupleData==HTuple("clear_shape_model")))
      {
        GetMessageTuple(hv_MessageInHandle, hv_Selection2, &hv_TupleData1);
        ClearShapeModel(hv_TupleData1);
      }
      else if (0 != (hv_TupleData==HTuple("clear_ocr_class_mlp")))
      {
        GetMessageTuple(hv_MessageInHandle, hv_Selection2, &hv_TupleData1);
        ClearOcrClassMlp(hv_TupleData1);
      }
      else if (0 != (hv_TupleData==HTuple("clear_text_model")))
      {
        GetMessageTuple(hv_MessageInHandle, hv_Selection2, &hv_TupleData1);
        ClearTextModel(hv_TupleData1);
      }
    }
  }
  }
  //
  //
  //
  ClearMessage(hv_MessageInHandle);
  return;
}

void load_config (HTuple hv_ParamSettingsFile, HTuple hv_section, HTuple hv_key, 
    HTuple hv_Defaultval, HTuple *hv_val)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_FileExists, hv_BaseName, hv_Extension;
  HTuple  hv_Directory, hv_Substrings, hv_Path;

  (*hv_val) = "";
  FileExists(hv_ParamSettingsFile, &hv_FileExists);
  if (0 != (hv_FileExists==0))
  {
    parse_filename(hv_ParamSettingsFile, &hv_BaseName, &hv_Extension, &hv_Directory);
    TupleSplit(hv_Directory, "/", &hv_Substrings);
    create_nodes(hv_Substrings, &hv_Path);
    //write_tuple (Defaultval, ParamSettingsFile)
    ExConfigIniCreate(hv_ParamSettingsFile);
  }
  else
  {
    ExConfigIniReadStr(hv_ParamSettingsFile, hv_section, hv_key, "", &(*hv_val));
  }
  if (0 != ((*hv_val)==HTuple("")))
  {
    TupleString(hv_Defaultval, "#", &hv_Defaultval);
    ExConfigIniWriteStr(hv_ParamSettingsFile, hv_section, hv_key, hv_Defaultval);
    (*hv_val) = hv_Defaultval;
  }
  return;
}

void create_nodes (HTuple hv_Nodes, HTuple *hv_Path)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_mp, hv_Index, hv_FileExists;

  hv_mp = "";
  {
  HTuple end_val1 = (hv_Nodes.TupleLength())-1;
  HTuple step_val1 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val1, step_val1); hv_Index += step_val1)
  {
    hv_mp = (hv_mp+HTuple(hv_Nodes[hv_Index]))+"/";
    FileExists(hv_mp, &hv_FileExists);
    if (0 != (hv_FileExists!=1))
    {
      MakeDir(hv_mp);
    }
  }
  }
  //
  (*hv_Path) = hv_mp;
  return;
}

void InitCheck (HTuple hv_TestName, HTuple hv_CameraIndex, HTuple hv_ImageW, HTuple hv_ImageH, 
    HTuple *hv_MessageHandle)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Exception, hv_DirName, hv_SystemPath;
  HTuple  hv_CurrentScheme, hv_BaseName, hv_Extension, hv_CurrentSchemePath;
  HTuple  hv_Position, hv_CheckParam, hv_DefectNames, hv_DefectVals;
  HTuple  ExpTmpLocalVar_G_DEEP_REGION, ExpTmpLocalVar_G_SHALLOW_REGION;
  HTuple  ExpTmpLocalVar_G_DEEP_REGION2, ExpTmpLocalVar_G_SHALLOW_REGION2;
  HTuple  ExpTmpLocalVar_G_AREA_MAX, hv_AREA_MAX, hv_Resolution_H;
  HTuple  hv_Resolution_W, hv_resolutionratio, hv_val, hv_lsCheckParam;

  try
  {
    SetMessageParam((*hv_MessageHandle), "remove_key", HTuple(), HTuple());
  }
  // catch (Exception) 
  catch (HalconCpp::HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    CreateMessage(&(*hv_MessageHandle));
  }
  SetMessageTuple((*hv_MessageHandle), "TestName", hv_TestName);
  SetMessageTuple((*hv_MessageHandle), "CameraIndex", hv_CameraIndex);
  SetMessageTuple((*hv_MessageHandle), "ImageW", hv_ImageW);
  SetMessageTuple((*hv_MessageHandle), "ImageH", hv_ImageH);
  //halcon检测参数总路径
  GetCurrentDir(&hv_DirName);
  hv_SystemPath = hv_DirName+"/SystemConfiguration/system.ini";
  SetMessageTuple((*hv_MessageHandle), "SystemPath", hv_SystemPath);
  //TestName+'_产品规格'

  //获取检测方案文件路径
  load_config(hv_SystemPath, hv_TestName, "当前方案ini", ("Setting\\ProductSN\\Parameters"+hv_TestName)+".ini", 
      &hv_CurrentScheme);
  parse_filename(hv_CurrentScheme, &hv_BaseName, &hv_Extension, &hv_CurrentSchemePath);
  TupleStrstr(hv_CurrentSchemePath, ":/", &hv_Position);
  if (0 != (HTuple(hv_Position[0])>0))
  {
    SetMessageTuple((*hv_MessageHandle), "CurrentSchemePath", hv_CurrentSchemePath);
    SetMessageTuple((*hv_MessageHandle), "CurrentScheme", hv_CurrentScheme);
  }
  else
  {
    hv_CurrentSchemePath = (hv_DirName+"/")+hv_CurrentSchemePath;
    hv_CurrentScheme = ((hv_CurrentSchemePath+hv_BaseName)+".")+hv_Extension;
    SetMessageTuple((*hv_MessageHandle), "CurrentSchemePath", hv_CurrentSchemePath);
    SetMessageTuple((*hv_MessageHandle), "CurrentScheme", hv_CurrentScheme);
  }
  //
  //
  loglog((*hv_MessageHandle), 1, "开始初始化参数");
  //
  //根据index获取检测算法
  load_config(hv_CurrentScheme, "方案", "检测方案", "不分类检测", &hv_CheckParam);
  SetMessageTuple((*hv_MessageHandle), "CheckParam", hv_CheckParam);
  //

  //
  load_config_keys_vals(hv_SystemPath, "ErrorIdentification", &hv_DefectNames, &hv_DefectVals);
  TupleString(hv_DefectNames, "#", &hv_DefectNames);
  TupleString(hv_DefectVals, "#", &hv_DefectVals);
  SetMessageTuple((*hv_MessageHandle), "DefectNames", hv_DefectNames);
  SetMessageTuple((*hv_MessageHandle), "DefectVals", hv_DefectVals);


  //表面检测
  //global tuple G_DEEP_REGION
  //global tuple G_SHALLOW_REGION
  //global tuple G_DEEP_REGION2
  //global tuple G_SHALLOW_REGION2
  ExpTmpLocalVar_G_DEEP_REGION = 0;
  ExpSetGlobalVar_G_DEEP_REGION(ExpTmpLocalVar_G_DEEP_REGION);
  ExpTmpLocalVar_G_SHALLOW_REGION = 1;
  ExpSetGlobalVar_G_SHALLOW_REGION(ExpTmpLocalVar_G_SHALLOW_REGION);
  ExpTmpLocalVar_G_DEEP_REGION2 = 2;
  ExpSetGlobalVar_G_DEEP_REGION2(ExpTmpLocalVar_G_DEEP_REGION2);
  ExpTmpLocalVar_G_SHALLOW_REGION2 = 3;
  ExpSetGlobalVar_G_SHALLOW_REGION2(ExpTmpLocalVar_G_SHALLOW_REGION2);
  //
  //
  //global tuple G_AREA_MAX
  ExpTmpLocalVar_G_AREA_MAX = 99999999;
  ExpSetGlobalVar_G_AREA_MAX(ExpTmpLocalVar_G_AREA_MAX);
  hv_AREA_MAX = ExpGetGlobalVar_G_AREA_MAX().TupleInt();


  //
  //['SystemPath']
  //[分辨率]
  load_config_set_message_Number((*hv_MessageHandle), hv_SystemPath, hv_TestName, 
      "纵向分辨率", "Resolution_H", 0.29, &hv_Resolution_H);
  load_config_set_message_Number((*hv_MessageHandle), hv_SystemPath, hv_TestName, 
      "横向分辨率", "Resolution_W", 0.38, &hv_Resolution_W);
  load_config_set_message_Number((*hv_MessageHandle), hv_SystemPath, hv_TestName, 
      "分辨率", "resolutionratio", 0.38, &hv_resolutionratio);
  //[基本参数]
  load_config_set_message_Number((*hv_MessageHandle), hv_CurrentScheme, "基本参数", 
      "单张记录数量", "MaxReturnNum", 7, &hv_val);


  TupleSplit(hv_CheckParam, "_", &hv_lsCheckParam);
  //共享内存初始化
  Init_Python_Memory(hv_CurrentScheme, "InitPyMemory", (*hv_MessageHandle));

  if (0 != (HTuple(hv_lsCheckParam[0])==HTuple("不分类检测")))
  {
    InitSurCheck((*hv_MessageHandle));
  }
  else if (0 != (HTuple(hv_lsCheckParam[0])==HTuple("MLP分类检测")))
  {

  }
  else if (0 != (HTuple(hv_lsCheckParam[0])==HTuple("SVM分类检测")))
  {
  }
  else if (0 != (HTuple(hv_lsCheckParam[0])==HTuple("地板检测")))
  {
    Init_FloorCheck(hv_CurrentScheme, hv_lsCheckParam, (*hv_MessageHandle));
  }
  else if (0 != (HTuple(hv_lsCheckParam[0])==HTuple("底面检测")))
  {
    Init_BottomSurfaceDetection(hv_CurrentScheme, hv_lsCheckParam, (*hv_MessageHandle));
  }
  else if (0 != (HTuple(hv_lsCheckParam[0])==HTuple("底凸检测")))
  {
    Init_BottomConvexDetection(hv_CurrentScheme, hv_lsCheckParam, (*hv_MessageHandle));
  }
  else if (0 != (HTuple(hv_lsCheckParam[0])==HTuple("顶面检测")))
  {
    Init_TopSurfaceDetection(hv_CurrentScheme, hv_lsCheckParam, (*hv_MessageHandle));
  }
  else if (0 != (HTuple(hv_lsCheckParam[0])==HTuple("侧面尺寸测量")))
  {
    Init_SideMeasurementDetection(hv_CurrentScheme, hv_lsCheckParam, (*hv_MessageHandle));
  }
  else if (0 != (HTuple(hv_lsCheckParam[0])==HTuple("字符和瑕疵检测")))
  {
    Init_OCRFlawDetection(hv_CurrentScheme, hv_lsCheckParam, hv_DirName, (*hv_MessageHandle));
  }
  //
  loglog((*hv_MessageHandle), 0, "完成参数初始化");
  return;

























}

void TrainNewModel (HTuple hv_MessageHandle, HTuple hv_WindowHandle, HTuple hv_ClassNames, 
    HTuple hv_ImagePaths)
{

  // Local iconic variables
  HObject  ho_Image;

  // Local control variables
  HTuple  hv_CheckParam, hv_CheckMode, hv_CheckFilePath;
  HTuple  hv_NumFeatures, hv_colors, hv_Nu, hv_KernelParam;
  HTuple  hv_ClassIndex, hv_ImageFiles, hv_Index3, hv_Error_info;
  HTuple  hv_Info, hv_Features, hv_SVMHandle1, hv_ClassTrainDataHandle1;
  HTuple  hv_ClassTrainDataHandle, hv_Error_info1;
  HTupleVector  hvec_Featureeeee(1), hvec_Info1(2);

  GetMessageTuple(hv_MessageHandle, "CheckParam", &hv_CheckParam);
  if (0 != (hv_CheckParam==HTuple("底面检测")))
  {
    //
    GetMessageTuple(hv_MessageHandle, "CheckMode", &hv_CheckMode);
    if (0 != (HTuple("SVM")==hv_CheckMode))
    {
      //
      GetMessageTuple(hv_MessageHandle, "CheckFilePath", &hv_CheckFilePath);
      //
    }
    hv_NumFeatures = 0;
    hv_colors.Clear();
    hv_colors[0] = "forest green";
    hv_colors[1] = "red";
    hv_Nu = 0.05;
    hv_KernelParam = 0.02;
    hvec_Featureeeee = (HTupleVector(1).Insert(0,HTupleVector(HTuple())));
    {
    HTuple end_val14 = (hv_ClassNames.TupleLength())-1;
    HTuple step_val14 = 1;
    for (hv_ClassIndex=0; hv_ClassIndex.Continue(end_val14, step_val14); hv_ClassIndex += step_val14)
    {
      //
      ListFiles(HTuple(hv_ImagePaths[hv_ClassIndex]), ((HTuple("files").Append("follow_links")).Append("recursive")), 
          &hv_ImageFiles);
      TupleRegexpSelect(hv_ImageFiles, (HTuple("\\.(tif|tiff|gif|bmp|jpg|jpeg|jp2|png|pcx|pgm|ppm|pbm|xwd|ima|hobj)$").Append("ignore_case")), 
          &hv_ImageFiles);
      {
      HTuple end_val18 = (hv_ImageFiles.TupleLength())-1;
      HTuple step_val18 = 1;
      for (hv_Index3=0; hv_Index3.Continue(end_val18, step_val18); hv_Index3 += step_val18)
      {
        ReadImage(&ho_Image, HTuple(hv_ImageFiles[hv_Index3]));
        PreprocessImage(ho_Image, &ho_Image, hv_MessageHandle);
        disp_message(hv_WindowHandle, HTuple(hv_ImageFiles[hv_Index3]), "window", 
            12, 12, "black", "true");
        downCheck(ho_Image, 1, hv_WindowHandle, hv_MessageHandle, hv_MessageHandle, 
            &hv_Error_info, &hv_Info);
        //DreiFeatureExtract (Image, WindowHandle, Features)
        hvec_Featureeeee.Insert(hvec_Featureeeee.Length()-1,HTupleVector(hv_Features));
        if (0 != (hv_NumFeatures==0))
        {
          hv_NumFeatures = hv_Features.TupleLength();
          CreateClassSvm(hv_NumFeatures, "rbf", hv_KernelParam, hv_Nu, hv_ClassNames.TupleLength(), 
              "one-versus-one", "principal_components", 5, &hv_SVMHandle1);
        }
        else if (0 != (hv_NumFeatures!=(hv_Features.TupleLength())))
        {
          // stop(); only in hdevelop
        }
        CreateClassTrainData(10, &hv_ClassTrainDataHandle1);
        AddClassTrainDataSvm(hv_SVMHandle1, hv_Features);
        GetClassTrainDataSvm(hv_SVMHandle1, &hv_ClassTrainDataHandle);
        TupleReal(hv_Features, &hv_Features);
        AddSampleClassSvm(hv_SVMHandle1, hv_Features, hv_ClassIndex);
      }
      }
    }
    }
    TrainClassSvm(hv_SVMHandle1, 0.001, "default");
    GetMessageTuple(hv_MessageHandle, "CheckFilePath", &hv_CheckFilePath);
    // stop(); only in hdevelop
    WriteClassSvm(hv_SVMHandle1, hv_CheckFilePath);
    ClearClassSvm(hv_SVMHandle1);
  }
  if (0 != (hv_CheckParam==HTuple("顶面检测")))
  {
    GetMessageTuple(hv_MessageHandle, "CheckMode", &hv_CheckMode);
    if (0 != (HTuple("SVM")==hv_CheckMode))
    {
      //
      GetMessageTuple(hv_MessageHandle, "CheckFilePath", &hv_CheckFilePath);
      //
    }
    hv_NumFeatures = 0;
    hv_colors.Clear();
    hv_colors[0] = "forest green";
    hv_colors[1] = "red";
    hv_Nu = 0.05;
    hv_KernelParam = 0.02;
    hvec_Featureeeee = (HTupleVector(1).Insert(0,HTupleVector(HTuple())));
    {
    HTuple end_val56 = (hv_ClassNames.TupleLength())-1;
    HTuple step_val56 = 1;
    for (hv_ClassIndex=0; hv_ClassIndex.Continue(end_val56, step_val56); hv_ClassIndex += step_val56)
    {
      //
      ListFiles(HTuple(hv_ImagePaths[hv_ClassIndex]), ((HTuple("files").Append("follow_links")).Append("recursive")), 
          &hv_ImageFiles);
      TupleRegexpSelect(hv_ImageFiles, (HTuple("\\.(tif|tiff|gif|bmp|jpg|jpeg|jp2|png|pcx|pgm|ppm|pbm|xwd|ima|hobj)$").Append("ignore_case")), 
          &hv_ImageFiles);
      {
      HTuple end_val60 = (hv_ImageFiles.TupleLength())-1;
      HTuple step_val60 = 1;
      for (hv_Index3=0; hv_Index3.Continue(end_val60, step_val60); hv_Index3 += step_val60)
      {
        ReadImage(&ho_Image, HTuple(hv_ImageFiles[hv_Index3]));
        PreprocessImage(ho_Image, &ho_Image, hv_MessageHandle);
        disp_message(hv_WindowHandle, HTuple(hv_ImageFiles[hv_Index3]), "window", 
            12, 12, "black", "true");
        Check_EinsFeatureExtract(ho_Image, 1, hv_MessageHandle, hv_WindowHandle, 
            &hv_MessageHandle, &hv_Error_info1, &hvec_Info1);
        //UpFaceCheck (Image, MessageHandle, WindowHandle, Features, IsTrue)
        hvec_Featureeeee.Insert(hvec_Featureeeee.Length()-1,HTupleVector(hv_Features));
        if (0 != (hv_NumFeatures==0))
        {
          hv_NumFeatures = hv_Features.TupleLength();
          CreateClassSvm(hv_NumFeatures, "rbf", hv_KernelParam, hv_Nu, hv_ClassNames.TupleLength(), 
              "one-versus-one", "principal_components", 5, &hv_SVMHandle1);
        }
        else if (0 != (hv_NumFeatures!=(hv_Features.TupleLength())))
        {
          // stop(); only in hdevelop
        }
        TupleReal(hv_Features, &hv_Features);
        AddSampleClassSvm(hv_SVMHandle1, hv_Features, hv_ClassIndex);
      }
      }
    }
    }
    TrainClassSvm(hv_SVMHandle1, 0.001, "default");
    GetMessageTuple(hv_MessageHandle, "CheckFilePath", &hv_CheckFilePath);
    // stop(); only in hdevelop
    WriteClassSvm(hv_SVMHandle1, hv_CheckFilePath);
    ClearClassSvm(hv_SVMHandle1);
  }
  return;
}

void SaveImage (HObject ho_Image, HTuple hv_filename)
{

  // Local control variables
  HTuple  hv_filenames;

  TupleSplit(hv_filename, ".", &hv_filenames);
  if (0 != ((hv_filenames.TupleLength())==2))
  {
    WriteImage(ho_Image, HTuple(hv_filenames[1]), 0, hv_filename);
  }
  return;
}

void downCheck (HObject ho_Image, HTuple hv_ShowHide, HTuple hv_WindowHandle, HTuple hv_MessageHandle, 
    HTuple hv_OutMessageHandle, HTuple *hv_Error_info, HTuple *hv_Info)
{

  // Local iconic variables
  HObject  ho_Circle, ho_ImageReduced, ho_Region;
  HObject  ho_RegionFillUp, ho_ConnectedRegions, ho_SelectedRegions;
  HObject  ho_ImageReduced1, ho_Edges, ho_SelectedContours;
  HObject  ho_RegionErosion, ho_RegionFillUp1, ho_Circle1;
  HObject  ho_ImageReduced2;

  // Local control variables
  HTuple  hv_Area, hv_Row1, hv_Column1, hv_Number;
  HTuple  hv_Circularity, hv_Mean, hv_Deviation, hv_Area2;
  HTuple  hv_Row4, hv_Column4, hv_CentArea, hv_CentCircularity;
  HTuple  hv_CentGVMean, hv_CentGVStd, hv_Number1, hv_Length;
  HTuple  hv_Sum, hv_CLSum, hv_Row2, hv_Column2, hv_Radius1;
  HTuple  hv_Area1, hv_Row3, hv_Column3, hv_EArea, hv_Features;

  (*hv_Error_info) = "";
  (*hv_Info) = HTuple();
  GetMessageObj(&ho_Circle, hv_MessageHandle, "Circle");
  SetMessageTuple(hv_OutMessageHandle, "Feature", HTuple());
  //
  ReduceDomain(ho_Image, ho_Circle, &ho_ImageReduced);
  Show_Hide(ho_Circle, hv_ShowHide, hv_WindowHandle);
  //
  //获取中心区域
  Threshold(ho_ImageReduced, &ho_Region, 160, 255);
  FillUp(ho_Region, &ho_RegionFillUp);
  Connection(ho_RegionFillUp, &ho_ConnectedRegions);
  AreaCenter(ho_ConnectedRegions, &hv_Area, &hv_Row1, &hv_Column1);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "area", "and", (hv_Area.TupleMax())-1, 
      (hv_Area.TupleMax())+1);
  ReduceDomain(ho_ImageReduced, ho_SelectedRegions, &ho_ImageReduced1);
  CountObj(ho_ImageReduced1, &hv_Number);
  if (0 != (hv_Number>0))
  {
    //Number判断是否获取到中心区域
    Circularity(ho_SelectedRegions, &hv_Circularity);
    Intensity(ho_SelectedRegions, ho_ImageReduced1, &hv_Mean, &hv_Deviation);
    AreaCenter(ho_SelectedRegions, &hv_Area2, &hv_Row4, &hv_Column4);
    hv_CentArea = hv_Area2;
    hv_CentCircularity = hv_Circularity;
    hv_CentGVMean = hv_Mean;
    hv_CentGVStd = hv_Deviation;
    //表面漏液检测
    EdgesSubPix(ho_ImageReduced1, &ho_Edges, "canny", 11, 10, 30);
    SelectContoursXld(ho_Edges, &ho_SelectedContours, "contour_length", 400, 2500, 
        -0.5, 0.5);
    CountObj(ho_SelectedContours, &hv_Number1);
    if (0 != (hv_Number1>0))
    {
      //Number1用来判断是否正确分割到中心区域的凹槽
      LengthXld(ho_SelectedContours, &hv_Length);
      TupleSum(hv_Length, &hv_Sum);
      hv_CLSum = hv_Sum;
    }
    else
    {
      hv_CLSum = 0;
    }
    //获取胶管区域
    Threshold(ho_ImageReduced, &ho_Region, 60, 130);
    ErosionCircle(ho_Region, &ho_RegionErosion, 11);
    FillUp(ho_RegionErosion, &ho_RegionFillUp1);
    SmallestCircle(ho_RegionFillUp1, &hv_Row2, &hv_Column2, &hv_Radius1);
    if (0 != (hv_Radius1>0))
    {
      //Radius1用来判断是否分割到产品边界
      GenCircle(&ho_Circle1, hv_Row2, hv_Column2, hv_Radius1);
      ReduceDomain(ho_ImageReduced, ho_Circle1, &ho_ImageReduced2);
      AreaCenter(ho_Circle1, &hv_Area1, &hv_Row3, &hv_Column3);
      hv_EArea = hv_Area1-hv_Area2;
    }
    else
    {
      hv_EArea = 0;
      //
    }
    //
    //
  }
  else
  {
    hv_CentArea = 0;
    hv_CentCircularity = 0;
    hv_CentGVMean = 0;
    hv_CentGVStd = 1024;
    hv_CLSum = 0;
    hv_EArea = 0;
  }
  //
  hv_Features.Clear();
  hv_Features.Append(hv_CentArea);
  hv_Features.Append(hv_CentCircularity);
  hv_Features.Append(hv_CentGVMean);
  hv_Features.Append(hv_CentGVStd);
  hv_Features.Append(hv_CLSum);
  hv_Features.Append(hv_EArea);
  SetMessageTuple(hv_OutMessageHandle, "Feature", hv_Features);
  return;
}

void getallmessage (HTuple hv_MessageHandle)
{

  // Local iconic variables
  HObject  ho_ObjectData;

  // Local control variables
  HTuple  hv_Allkeys, hv_Index, hv_key_data_type;
  HTuple  hv_val;

  GetMessageParam(hv_MessageHandle, "message_keys", HTuple(), &hv_Allkeys);
  {
  HTuple end_val1 = (hv_Allkeys.TupleLength())-1;
  HTuple step_val1 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val1, step_val1); hv_Index += step_val1)
  {
    GetMessageParam(hv_MessageHandle, "key_data_type", HTuple(hv_Allkeys[hv_Index]), 
        &hv_key_data_type);
    if (0 != (hv_key_data_type==HTuple("tuple")))
    {
      GetMessageTuple(hv_MessageHandle, HTuple(hv_Allkeys[hv_Index]), &hv_val);
    }
    else
    {
      GetMessageObj(&ho_ObjectData, hv_MessageHandle, HTuple(hv_Allkeys[hv_Index]));
      //
    }
  }
  }
  return;
}

void GetResult (HTuple hv_Resultstrs, HTuple *hv_ResultName, HTuple *hv_Resultstrs2)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Resultstrs1, hv_NumMatches, hv_Index;
  HTuple  hv_NumMatche, hv_Index1;

  (*hv_ResultName) = "OK";
  TupleString(hv_Resultstrs, "#", &hv_Resultstrs);
  TupleRegexpReplace(hv_Resultstrs, (HTuple("ok|OK|Ok|oK|").Append("ignore_case")), 
      "", &hv_Resultstrs1);
  TupleDifference(hv_Resultstrs1, "", &(*hv_Resultstrs2));
  if (0 != (((*hv_Resultstrs2).TupleLength())==0))
  {
    (*hv_ResultName) = "OK";
  }
  else
  {
    hv_NumMatches = HTuple();
    {
    HTuple end_val8 = ((*hv_Resultstrs2).TupleLength())-1;
    HTuple step_val8 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val8, step_val8); hv_Index += step_val8)
    {
      TupleRegexpTest(hv_Resultstrs1, HTuple((*hv_Resultstrs2)[hv_Index]), &hv_NumMatche);
      hv_NumMatches = hv_NumMatches.TupleConcat(hv_NumMatche);
    }
    }
    TupleFindFirst(hv_NumMatches, hv_NumMatches.TupleMax(), &hv_Index1);
    (*hv_ResultName) = ((const HTuple&)(*hv_Resultstrs2))[hv_Index1];
  }
  return;
}

void gen_region_byTypeAndStr (HObject *ho_Region, HTuple hv_Type, HTuple hv_str, 
    HTuple *hv_Vals)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Substrings;

  GenEmptyRegion(&(*ho_Region));
  TupleSplit(hv_str, ",", &hv_Substrings);
  (*hv_Vals) = hv_str;
  if (0 != (HTuple(hv_Type==HTuple("circle")).TupleAnd((hv_Substrings.TupleLength())>=3)))
  {
    TupleNumber(hv_Substrings, &(*hv_Vals));
    GenCircle(&(*ho_Region), HTuple((*hv_Vals)[0]), HTuple((*hv_Vals)[1]), HTuple((*hv_Vals)[2]));
  }
  else if (0 != (HTuple(hv_Type==HTuple("circle_arc")).TupleAnd((hv_Substrings.TupleLength())>=5)))
  {
    TupleNumber(hv_Substrings, &(*hv_Vals));
    GenCircleSector(&(*ho_Region), HTuple((*hv_Vals)[0]), HTuple((*hv_Vals)[1]), 
        HTuple((*hv_Vals)[2]), HTuple((*hv_Vals)[3]), HTuple((*hv_Vals)[4]));
  }
  else if (0 != (HTuple(hv_Type==HTuple("ellipse")).TupleAnd((hv_Substrings.TupleLength())>=5)))
  {
    TupleNumber(hv_Substrings, &(*hv_Vals));
    GenEllipse(&(*ho_Region), HTuple((*hv_Vals)[0]), HTuple((*hv_Vals)[1]), HTuple((*hv_Vals)[2]), 
        HTuple((*hv_Vals)[3]), HTuple((*hv_Vals)[4]));
  }
  else if (0 != (HTuple(hv_Type==HTuple("ellipse_arc")).TupleAnd((hv_Substrings.TupleLength())>=7)))
  {
    TupleNumber(hv_Substrings, &(*hv_Vals));
    GenEllipseSector(&(*ho_Region), HTuple((*hv_Vals)[0]), HTuple((*hv_Vals)[1]), 
        HTuple((*hv_Vals)[2]), HTuple((*hv_Vals)[3]), HTuple((*hv_Vals)[4]), HTuple((*hv_Vals)[5]), 
        HTuple((*hv_Vals)[6]));
  }
  else if (0 != (HTuple(hv_Type==HTuple("line")).TupleAnd((hv_Substrings.TupleLength())>=4)))
  {
    TupleNumber(hv_Substrings, &(*hv_Vals));
    GenRegionLine(&(*ho_Region), HTuple((*hv_Vals)[0]), HTuple((*hv_Vals)[1]), HTuple((*hv_Vals)[2]), 
        HTuple((*hv_Vals)[3]));
  }
  else if (0 != (HTuple(hv_Type==HTuple("rectangle1")).TupleAnd((hv_Substrings.TupleLength())>=4)))
  {
    TupleNumber(hv_Substrings, &(*hv_Vals));
    //
    GenRectangle1(&(*ho_Region), HTuple((*hv_Vals)[0]), HTuple((*hv_Vals)[1]), HTuple((*hv_Vals)[2]), 
        HTuple((*hv_Vals)[3]));
  }
  else if (0 != (HTuple(hv_Type==HTuple("rectangle2")).TupleAnd((hv_Substrings.TupleLength())>=5)))
  {
    TupleNumber(hv_Substrings, &(*hv_Vals));
    GenRectangle2(&(*ho_Region), HTuple((*hv_Vals)[0]), HTuple((*hv_Vals)[1]), HTuple((*hv_Vals)[2]), 
        HTuple((*hv_Vals)[3]), HTuple((*hv_Vals)[4]));
  }
  return;
}

void TrainTestSvm (HTuple hv_ShowHide, HTuple hv_WindowHandle, HTuple hv_MessageHandle, 
    HTuple hv_OutMessageHandle)
{

  // Local iconic variables
  HObject  ho_Image, ho_PreprocessImage;

  // Local control variables
  HTuple  hv_ClassNames, hv_ImageP, hv_CheckMode;
  HTuple  hv_KernelTypes, hv_KernelParams, hv_Nus, hv_NumClasses;
  HTuple  hv_Modes, hv_Preprocessings, hv_NumComponents, hv_KernelType;
  HTuple  hv_KernelParam, hv_Nu, hv_NumClass, hv_Mode, hv_Preprocessing;
  HTuple  hv_NumComponent, hv_TrainIndex, hv_OKnum, hv_NGnum;
  HTuple  hv_ImageFiles, hv_Index, hv_ImageFile, hv_SVMHandle;
  HTuple  hv_Index1, hv_Exception, hv_Real, hv_Feature, hv_Result;
  HTuple  hv_Position1, hv_CheckFilePath, hv_FileExists;
  HTupleVector  hvec_vFeatures(1);

  hv_ClassNames.Clear();
  hv_ClassNames[0] = "OK";
  hv_ClassNames[1] = "NG";
  GetMessageTuple(hv_MessageHandle, "TrainImagePaths", &hv_ImageP);
  //
  GetMessageTuple(hv_MessageHandle, "CheckMode", &hv_CheckMode);
  if (0 != (hv_CheckMode==HTuple("SVM")))
  {
    hv_KernelTypes.Clear();
    hv_KernelTypes[0] = "linear";
    hv_KernelTypes[1] = "polynomial_homogeneous";
    hv_KernelTypes[2] = "polynomial_inhomogeneous";
    hv_KernelTypes[3] = "rbf";
    hv_KernelParams.Clear();
    hv_KernelParams[0] = 0.02;
    hv_KernelParams[1] = 0.01;
    hv_KernelParams[2] = 0.05;
    hv_KernelParams[3] = 0.1;
    hv_KernelParams[4] = 0.5;
    hv_Nus.Clear();
    hv_Nus[0] = 0.05;
    hv_Nus[1] = 0.0001;
    hv_Nus[2] = 0.001;
    hv_Nus[3] = 0.01;
    hv_Nus[4] = 0.1;
    hv_Nus[5] = 0.2;
    hv_Nus[6] = 0.3;
    hv_NumClasses.Clear();
    hv_NumClasses[0] = 2;
    hv_NumClasses[1] = 3;
    hv_NumClasses[2] = 4;
    hv_NumClasses[3] = 5;
    hv_NumClasses[4] = 6;
    hv_NumClasses[5] = 7;
    hv_NumClasses[6] = 8;
    hv_NumClasses[7] = 9;
    hv_NumClasses[8] = 10;
    hv_Modes.Clear();
    hv_Modes[0] = "novelty-detection";
    hv_Modes[1] = "one-versus-all";
    hv_Modes[2] = "one-versus-one";
    hv_Preprocessings.Clear();
    hv_Preprocessings[0] = "canonical_variates";
    hv_Preprocessings[1] = "none";
    hv_Preprocessings[2] = "normalization";
    hv_Preprocessings[3] = "principal_components";
    hv_NumComponents.Clear();
    hv_NumComponents[0] = 10;
    hv_NumComponents[1] = 1;
    hv_NumComponents[2] = 2;
    hv_NumComponents[3] = 3;
    hv_NumComponents[4] = 4;
    hv_NumComponents[5] = 5;
    hv_NumComponents[6] = 8;
    hv_NumComponents[7] = 10;
    hv_NumComponents[8] = 15;
    hv_NumComponents[9] = 20;
    hv_NumComponents[10] = 30;
    hv_NumComponents[11] = 40;
    hv_NumComponents[12] = 50;
    hv_NumComponents[13] = 60;
    hv_NumComponents[14] = 70;
    hv_NumComponents[15] = 80;
    hv_NumComponents[16] = 90;
    hv_NumComponents[17] = 100;
    hv_KernelType = ((const HTuple&)hv_KernelTypes)[0];
    hv_KernelParam = ((const HTuple&)hv_KernelParams)[0];
    hv_Nu = ((const HTuple&)hv_Nus)[0];
    hv_NumClass = ((const HTuple&)hv_NumClasses)[0];
    hv_Mode = ((const HTuple&)hv_Modes)[0];
    hv_Preprocessing = ((const HTuple&)hv_Preprocessings)[0];
    hv_NumComponent = ((const HTuple&)hv_NumComponents)[0];
    //
    hv_TrainIndex = 0;
    hvec_vFeatures = (HTupleVector(1).Insert(0,HTupleVector(HTuple())));
    //训练的文件路径
    hv_OKnum = 0;
    hv_NGnum = 0;
    hv_ImageFiles = HTuple();
    {
    HTuple end_val26 = (hv_ImageP.TupleLength())-1;
    HTuple step_val26 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val26, step_val26); hv_Index += step_val26)
    {
      ListFiles(HTuple(hv_ImageP[hv_Index]), ((HTuple("files").Append("follow_links")).Append("recursive")), 
          &hv_ImageFile);
      hv_ImageFiles = hv_ImageFiles.TupleConcat(hv_ImageFile);
    }
    }
    //
    TupleRegexpSelect(hv_ImageFiles, (HTuple("\\.(tif|tiff|gif|bmp|jpg|jpeg|jp2|png|pcx|pgm|ppm|pbm|xwd|ima|hobj)$").Append("ignore_case")), 
        &hv_ImageFiles);
    TupleRegexpSelect(hv_ImageFiles, "实时图像7", &hv_ImageFiles);
    hv_SVMHandle = HTuple();
    {
    HTuple end_val34 = (hv_ImageFiles.TupleLength())-1;
    HTuple step_val34 = 1;
    for (hv_Index1=0; hv_Index1.Continue(end_val34, step_val34); hv_Index1 += step_val34)
    {
      hv_ImageFile = ((const HTuple&)hv_ImageFiles)[hv_Index1];
      ReadImage(&ho_Image, hv_ImageFile);
      try
      {
        PreprocessImage(ho_Image, &ho_PreprocessImage, hv_MessageHandle);
        Show_Hide(ho_PreprocessImage, hv_ShowHide, hv_WindowHandle);
        //HCheck (PreprocessImage, ShowHide, Index1, WindowHandle, OutMessageHandle, MessageHandle)
      }
      // catch (Exception) 
      catch (HalconCpp::HException &HDevExpDefaultException)
      {
        HDevExpDefaultException.ToHTuple(&hv_Exception);
      }
      GetMessageTuple(hv_MessageHandle, "Feature", &hv_Real);
      TupleReal(hv_Real, &hv_Real);
      if (0 != ((hv_Real.TupleLength())>0))
      {
        if (0 != ((hv_SVMHandle.TupleLength())==0))
        {
          CreateClassSvm(hv_Real.TupleLength(), "rbf", hv_KernelParam, hv_Nu, 2, 
              "one-versus-one", "normalization", 10, &hv_SVMHandle);
        }
        hv_Feature.Clear();
        hv_Feature.Append(HTuple(hv_ClassNames[0]));
        hv_Feature.Append(hv_ImageFile);
        hv_Feature.Append(hv_Real);
        hvec_vFeatures.Insert(hvec_vFeatures.Length(),HTupleVector(hv_Feature));
        TupleRegexpReplace(hv_ImageFile, hv_ImageP, "", &hv_Result);
        TupleStrstr(hv_Result, "OK", &hv_Position1);
        //
        if (0 != (hv_Position1>=0))
        {
          //disp_message (WindowHandle, 'OK', 'image', 12, 12, 'black', 'true')
          AddSampleClassSvm(hv_SVMHandle, hv_Real, 0);
          hv_OKnum += 1;
          //
        }
        else
        {
          //disp_message (WindowHandle, 'NG', 'window', 12, 12, 'black', 'true')
          AddSampleClassSvm(hv_SVMHandle, hv_Real, 1);
          hv_NGnum += 1;
        }
      }
      //
      //stop ()
    }
    }
    SetMessageTuple(hv_OutMessageHandle, "OKnum", hv_OKnum);
    SetMessageTuple(hv_OutMessageHandle, "NGnum", hv_NGnum);
    if (0 != hv_ShowHide)
    {
      disp_message(hv_WindowHandle, ((("NG:"+hv_NGnum)+"\r\n")+"OKnum")+hv_OKnum, 
          "image", 0, 0, "black", "true");
    }
    if (0 != (HTuple(hv_OKnum>2).TupleAnd(hv_NGnum>2)))
    {
      //'add_sv_to_train_set', 'default'
      GetMessageTuple(hv_MessageHandle, "CheckFilePath", &hv_CheckFilePath);
      //
      TrainClassSvm(hv_SVMHandle, 0.001, "default");
      FileExists(hv_CheckFilePath, &hv_FileExists);
      if (0 != (hv_FileExists==1))
      {
        // stop(); only in hdevelop
      }
      WriteClassSvm(hv_SVMHandle, hv_CheckFilePath);
      ClearClassSvm(hv_SVMHandle);
    }
  }
  //
  return;
}

void Show_Hide (HObject ho_obj, HTuple hv_ShowHide, HTuple hv_WindowHandle)
{

  if (0 != hv_ShowHide)
  {
    DispObj(ho_obj, hv_WindowHandle);
  }
  return;
}

void HCheck (HObject ho_Image, HObject *ho_PreprocessImage, HTuple hv_IndexSN, HTuple hv_ShowHide, 
    HTuple hv_WindowHandle, HTuple hv_MessageHandle, HTuple *hv_ResultInfo, HTuple *hv_WindowInfo, 
    HTupleVector/*{eTupleVector,Dim=2}*/ *hvec_FeatureVals)
{

  // Local iconic variables
  HObject  ho_ImageMirror;

  // Local control variables
  HTuple  hv_IndexSsN, hv_lsClassResult, hv_CheckParam;
  HTuple  hv_lsCheckParam, hv_Width, hv_Height, hv_outResultInfo;
  HTuple  hv_outWindowInfo, hv_outVectorInfos;
  HTupleVector  hvec_outFeatureVals(2);


  (*hv_ResultInfo) = "";
  (*hv_WindowInfo) = HTuple();
  (*hvec_FeatureVals) = HTupleVector(2);

  TupleString(hv_IndexSN, "#", &hv_IndexSsN);
  SetMessageTuple(hv_MessageHandle, "IndexSsN", hv_IndexSsN);
  hv_lsClassResult[0] = 1;
  GetMessageTuple(hv_MessageHandle, "CheckParam", &hv_CheckParam);
  (*hv_WindowInfo) = (*hv_WindowInfo).TupleConcat("检测方案:"+hv_CheckParam);
  //预处理图像
  TupleSplit(hv_CheckParam, "_", &hv_lsCheckParam);
  if (0 != (HTuple(hv_lsCheckParam[0])==HTuple("字符和瑕疵检测")))
  {
    MirrorImage(ho_Image, &ho_ImageMirror, "row");
    RotateImage(ho_ImageMirror, &(*ho_PreprocessImage), -90, "constant");

  }
  else
  {
    CopyImage(ho_Image, &(*ho_PreprocessImage));
  }
  GetImageSize((*ho_PreprocessImage), &hv_Width, &hv_Height);
  SetPart(hv_WindowHandle, 0, 0, hv_Height, hv_Width);
  DispImage((*ho_PreprocessImage), hv_WindowHandle);



  hv_outResultInfo = "";
  hv_outWindowInfo = HTuple();
  hvec_outFeatureVals = HTupleVector(2);
  if (0 != (HTuple(hv_lsCheckParam[0])==HTuple("不分类检测")))
  {
    Check_Surface((*ho_PreprocessImage), hv_ShowHide, hv_WindowHandle, hv_MessageHandle, 
        &hv_outResultInfo, &hv_outWindowInfo, &hvec_outFeatureVals);
  }
  else if (0 != (HTuple(hv_lsCheckParam[0])==HTuple("MLP分类检测")))
  {
    //
  }
  else if (0 != (HTuple(hv_lsCheckParam[0])==HTuple("SVM分类检测")))
  {

  }
  else if (0 != (HTuple(hv_lsCheckParam[0])==HTuple("地板检测")))
  {
    Check_Floor((*ho_PreprocessImage), hv_ShowHide, hv_WindowHandle, hv_MessageHandle, 
        &hv_outResultInfo, &hv_outVectorInfos, &hvec_outFeatureVals);
  }
  else if (0 != (HTuple(hv_lsCheckParam[0])==HTuple("底面检测")))
  {
    Check_DownSur((*ho_PreprocessImage), hv_ShowHide, hv_WindowHandle, hv_MessageHandle, 
        &hv_outResultInfo, &hv_outWindowInfo, &hvec_outFeatureVals);
  }
  else if (0 != (HTuple(hv_lsCheckParam[0])==HTuple("底凸检测")))
  {
    Check_Sur((*ho_PreprocessImage), hv_ShowHide, hv_WindowHandle, hv_MessageHandle, 
        &hv_outResultInfo, &hv_outWindowInfo, &hvec_outFeatureVals);
  }
  else if (0 != (HTuple(hv_lsCheckParam[0])==HTuple("顶面检测")))
  {
    Check_EinsFeatureExtract((*ho_PreprocessImage), hv_ShowHide, hv_WindowHandle, 
        hv_MessageHandle, &hv_outResultInfo, &hv_outWindowInfo, &hvec_outFeatureVals);
  }
  else if (0 != (HTuple(hv_lsCheckParam[0])==HTuple("侧面尺寸测量")))
  {
    Check_Side((*ho_PreprocessImage), hv_ShowHide, hv_WindowHandle, hv_MessageHandle, 
        &hv_outResultInfo, &hv_outWindowInfo, &hvec_outFeatureVals);
  }
  else if (0 != (HTuple(hv_lsCheckParam[0])==HTuple("字符和瑕疵检测")))
  {

    Check_OCR((*ho_PreprocessImage), hv_ShowHide, hv_WindowHandle, hv_MessageHandle, 
        &hv_outResultInfo, &hv_outWindowInfo, &hvec_outFeatureVals);


  }
  else
  {
    hv_outResultInfo = "OK";
    hv_outWindowInfo = "找不到检测模板";
  }
  (*hv_ResultInfo) = hv_outResultInfo;
  (*hv_WindowInfo).Clear();
  (*hv_WindowInfo).Append("检测:"+hv_outResultInfo);
  (*hv_WindowInfo).Append(hv_outWindowInfo);
  (*hv_WindowInfo).Append(hv_lsCheckParam);
  (*hvec_FeatureVals) = hvec_outFeatureVals;
  if (0 != hv_ShowHide)
  {
    if (0 != ((*hv_ResultInfo)==HTuple("OK")))
    {
      disp_message(hv_WindowHandle, (*hv_WindowInfo), "image", 10, 10, "green", "true");
    }
    else
    {
      disp_message(hv_WindowHandle, (*hv_WindowInfo), "image", 10, 10, "red", "true");
    }
  }
  hvec_outFeatureVals = HTupleVector(2);
  return;
}

void get_param_by_drawID (HTuple hv_DrawID, HTuple *hv_ParamType, HTuple *hv_Paramstr, 
    HTuple *hv_ParamNote, HTuple *hv_ParamData)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_ParamVal, hv_Param0, hv_Param1, hv_Param2;
  HTuple  hv_Param3, hv_Param4, hv_Param5, hv_Param6, hv_Index1;
  HTuple  hv_Paramcolor, hv_Exception;

  (*hv_Paramstr) = "";
  (*hv_ParamData) = HTuple();
  (*hv_ParamNote) = HTuple();
  hv_ParamVal = HTuple();
  try
  {
    GetDrawingObjectParams(hv_DrawID, "type", &(*hv_ParamType));
    if (0 != ((*hv_ParamType)==HTuple("circle")))
    {
      GetDrawingObjectParams(hv_DrawID, "row", &hv_Param0);
      GetDrawingObjectParams(hv_DrawID, "column", &hv_Param1);
      GetDrawingObjectParams(hv_DrawID, "radius", &hv_Param2);
      (*hv_ParamNote).Clear();
      (*hv_ParamNote)[0] = "row";
      (*hv_ParamNote)[1] = "column";
      (*hv_ParamNote)[2] = "radius";
      hv_ParamVal.Clear();
      hv_ParamVal.Append(hv_Param0);
      hv_ParamVal.Append(hv_Param1);
      hv_ParamVal.Append(hv_Param2);
    }
    else if (0 != ((*hv_ParamType)==HTuple("circle_arc")))
    {
      GetDrawingObjectParams(hv_DrawID, "row", &hv_Param0);
      GetDrawingObjectParams(hv_DrawID, "column", &hv_Param1);
      GetDrawingObjectParams(hv_DrawID, "radius", &hv_Param2);
      GetDrawingObjectParams(hv_DrawID, "start_angle", &hv_Param3);
      GetDrawingObjectParams(hv_DrawID, "end_angle", &hv_Param4);
      (*hv_ParamNote).Clear();
      (*hv_ParamNote)[0] = "row";
      (*hv_ParamNote)[1] = "column";
      (*hv_ParamNote)[2] = "radius";
      (*hv_ParamNote)[3] = "start_angle";
      (*hv_ParamNote)[4] = "end_angle";
      hv_ParamVal.Clear();
      hv_ParamVal.Append(hv_Param0);
      hv_ParamVal.Append(hv_Param1);
      hv_ParamVal.Append(hv_Param2);
      hv_ParamVal.Append(hv_Param3);
      hv_ParamVal.Append(hv_Param4);
    }
    else if (0 != ((*hv_ParamType)==HTuple("ellipse")))
    {
      GetDrawingObjectParams(hv_DrawID, "row", &hv_Param0);
      GetDrawingObjectParams(hv_DrawID, "column", &hv_Param1);
      GetDrawingObjectParams(hv_DrawID, "phi", &hv_Param2);
      GetDrawingObjectParams(hv_DrawID, "radius1", &hv_Param3);
      GetDrawingObjectParams(hv_DrawID, "radius2", &hv_Param4);
      (*hv_ParamNote).Clear();
      (*hv_ParamNote)[0] = "row";
      (*hv_ParamNote)[1] = "column";
      (*hv_ParamNote)[2] = "phi";
      (*hv_ParamNote)[3] = "radius1";
      (*hv_ParamNote)[4] = "radius2";
      hv_ParamVal.Clear();
      hv_ParamVal.Append(hv_Param0);
      hv_ParamVal.Append(hv_Param1);
      hv_ParamVal.Append(hv_Param2);
      hv_ParamVal.Append(hv_Param3);
      hv_ParamVal.Append(hv_Param4);
    }
    else if (0 != ((*hv_ParamType)==HTuple("ellipse_arc")))
    {
      GetDrawingObjectParams(hv_DrawID, "row", &hv_Param0);
      GetDrawingObjectParams(hv_DrawID, "column", &hv_Param1);
      GetDrawingObjectParams(hv_DrawID, "phi", &hv_Param2);
      GetDrawingObjectParams(hv_DrawID, "radius1", &hv_Param3);
      GetDrawingObjectParams(hv_DrawID, "radius2", &hv_Param4);
      GetDrawingObjectParams(hv_DrawID, "start_angle", &hv_Param5);
      GetDrawingObjectParams(hv_DrawID, "end_angle", &hv_Param6);
      (*hv_ParamNote).Clear();
      (*hv_ParamNote)[0] = "row";
      (*hv_ParamNote)[1] = "column";
      (*hv_ParamNote)[2] = "phi";
      (*hv_ParamNote)[3] = "radius1";
      (*hv_ParamNote)[4] = "radius2";
      (*hv_ParamNote)[5] = "start_angle";
      (*hv_ParamNote)[6] = "end_angle";
      hv_ParamVal.Clear();
      hv_ParamVal.Append(hv_Param0);
      hv_ParamVal.Append(hv_Param1);
      hv_ParamVal.Append(hv_Param2);
      hv_ParamVal.Append(hv_Param3);
      hv_ParamVal.Append(hv_Param4);
      hv_ParamVal.Append(hv_Param5);
      hv_ParamVal.Append(hv_Param6);
    }
    else if (0 != ((*hv_ParamType)==HTuple("line")))
    {
      GetDrawingObjectParams(hv_DrawID, "row1", &hv_Param0);
      GetDrawingObjectParams(hv_DrawID, "column1", &hv_Param1);
      GetDrawingObjectParams(hv_DrawID, "row2", &hv_Param2);
      GetDrawingObjectParams(hv_DrawID, "column2", &hv_Param3);
      (*hv_ParamNote).Clear();
      (*hv_ParamNote)[0] = "row1";
      (*hv_ParamNote)[1] = "column1";
      (*hv_ParamNote)[2] = "row2";
      (*hv_ParamNote)[3] = "column2";
      hv_ParamVal.Clear();
      hv_ParamVal.Append(hv_Param0);
      hv_ParamVal.Append(hv_Param1);
      hv_ParamVal.Append(hv_Param2);
      hv_ParamVal.Append(hv_Param3);
    }
    else if (0 != ((*hv_ParamType)==HTuple("rectangle1")))
    {
      GetDrawingObjectParams(hv_DrawID, "row1", &hv_Param0);
      GetDrawingObjectParams(hv_DrawID, "column1", &hv_Param1);
      GetDrawingObjectParams(hv_DrawID, "row2", &hv_Param2);
      GetDrawingObjectParams(hv_DrawID, "column2", &hv_Param3);
      (*hv_ParamNote).Clear();
      (*hv_ParamNote)[0] = "row1";
      (*hv_ParamNote)[1] = "column1";
      (*hv_ParamNote)[2] = "row2";
      (*hv_ParamNote)[3] = "column2";
      hv_ParamVal.Clear();
      hv_ParamVal.Append(hv_Param0);
      hv_ParamVal.Append(hv_Param1);
      hv_ParamVal.Append(hv_Param2);
      hv_ParamVal.Append(hv_Param3);
    }
    else if (0 != ((*hv_ParamType)==HTuple("rectangle2")))
    {
      GetDrawingObjectParams(hv_DrawID, "row", &hv_Param0);
      GetDrawingObjectParams(hv_DrawID, "column", &hv_Param1);
      GetDrawingObjectParams(hv_DrawID, "phi", &hv_Param2);
      GetDrawingObjectParams(hv_DrawID, "length1", &hv_Param3);
      GetDrawingObjectParams(hv_DrawID, "length2", &hv_Param4);
      (*hv_ParamNote).Clear();
      (*hv_ParamNote)[0] = "row";
      (*hv_ParamNote)[1] = "column";
      (*hv_ParamNote)[2] = "phi";
      (*hv_ParamNote)[3] = "length1";
      (*hv_ParamNote)[4] = "length2";
      hv_ParamVal.Clear();
      hv_ParamVal.Append(hv_Param0);
      hv_ParamVal.Append(hv_Param1);
      hv_ParamVal.Append(hv_Param2);
      hv_ParamVal.Append(hv_Param3);
      hv_ParamVal.Append(hv_Param4);
    }
    if (0 != ((hv_ParamVal.TupleLength())>0))
    {
      (*hv_Paramstr) = ((const HTuple&)hv_ParamVal)[0];
      {
      HTuple end_val63 = (hv_ParamVal.TupleLength())-1;
      HTuple step_val63 = 1;
      for (hv_Index1=1; hv_Index1.Continue(end_val63, step_val63); hv_Index1 += step_val63)
      {
        (*hv_Paramstr) = ((*hv_Paramstr)+",")+HTuple(hv_ParamVal[hv_Index1]);
      }
      }
    }
    GetDrawingObjectParams(hv_DrawID, "color", &hv_Paramcolor);
    (*hv_ParamNote) = (HTuple("type").Append("color")).TupleConcat((*hv_ParamNote));
    (*hv_ParamData).Clear();
    (*hv_ParamData).Append((*hv_ParamType));
    (*hv_ParamData).Append(hv_Paramcolor);
    (*hv_ParamData).Append(hv_ParamVal);
  }
  // catch (Exception) 
  catch (HalconCpp::HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
  }
  //
  return;
}

void CalculateFeatures (HObject ho_InputRegion, HObject ho_Image, HObject ho_DynThreshRegion1, 
    HObject ho_DynThreshRegion2, HObject ho_DynThreshRegion3, HObject ho_DynThreshRegion4, 
    HTuple hv_ProdR1, HTuple hv_ProdR2, HTuple hv_ProdC1, HTuple hv_ProdC2, HTuple hv_MessageHandle, 
    HTupleVector/*{eTupleVector,Dim=1}*/ *hvec_FeatureVals)
{

  // Local iconic variables
  HObject  ho_imgRect, ho_imgSmall, ho_regionDyn;
  HObject  ho_threshArea;

  // Local control variables
  HTuple  hv_Features_retResults_ifTag, hv_Features_ifCrowded;
  HTuple  hv_errR1, hv_errC1, hv_errR2, hv_errC2, hv_imgR1;
  HTuple  hv_imgR2, hv_imgC1, hv_imgC2, hv_subSet1, hv_subSet2;
  HTuple  hv_subSet3, hv_subSet4, hv_DEEP_REGION, hv_SHALLOW_REGION;
  HTuple  hv_DEEP_REGION2, hv_SHALLOW_REGION2, hv_Features_properDynThresh;
  HTuple  hv_regionArea, hv_NULL, hv_regionMean, hv_regionDeviation;
  HTuple  hv_Features_regionWidthPix, hv_Features_regionHeightPix;
  HTuple  hv_Resolution_H, hv_Resolution_W, hv_errDiam, hv_errArea;
  HTuple  hv_errCenterR, hv_errCenterC, hv_Features_errAreaPix;
  HTuple  hv_Features_retResults_rectvals, hv_Surf_Calib2;
  HTuple  hv_Surf_Calib, hv_Features_retResults_ErrorArea;
  HTuple  hv_Features_retResults_Diameter, hv_Surf_Area_Min;
  HTuple  hv_Features_retResults_nLevel, hv_Features_retResults_x;
  HTuple  hv_Features_retResults_y, hv_Surf_iMinWidthGray;
  HTuple  hv_Surf_iMaxWidthGray, hv_threshR1, hv_threshC1;
  HTuple  hv_threshR2, hv_threshC2, hv_Features_errHeight;
  HTuple  hv_Features_errWidth, hv_Surf_ShallowSizePixS2;
  HTuple  hv_Surf_iRecordWidthLine, hv_Surf_fHorAndVorRatio;
  HTuple  hv_Surf_DeepSizePixL2, hv_Surf_DeepSizePixM2, hv_Surf_DeepSizePixS2;
  HTuple  hv_Surf_ShallowSizePixL2, hv_Surf_ShallowSizePixM2;
  HTuple  hv_Surf_DeepSizePixL, hv_Surf_DeepSizePixM, hv_Surf_DeepSizePixS;
  HTuple  hv_retClass, hv_LabelNames, hv_LabelIndices, hv_AlarmNames;
  HTuple  hv_AlarmIndices, hv_Features_retResults_Alarm, hv_Features_retResults_Errortype;
  HTuple  hv_DefectNames, hv_DefectVals, hv_firstIndex, hv_Features_retResults_strErrortype;

  (*hvec_FeatureVals) = (HTupleVector(1).Insert(0,HTupleVector(HTuple())));
  (*hvec_FeatureVals).Clear();

  //'Features_ifCrowded'是否密度过大
  (*hvec_FeatureVals).Insert((*hvec_FeatureVals).Length(),HTupleVector((HTuple("Features_ifCrowded").Append(0))));
  hv_Features_retResults_ifTag = 0;
  hv_Features_ifCrowded = 0;
  ////缺陷最小矩形
  SmallestRectangle1(ho_InputRegion, &hv_errR1, &hv_errC1, &hv_errR2, &hv_errC2);
  ////局部小区域,这里要根据先前检测出的实际产品四周坐标来决定，而不是整个图像的四周坐标
  if (0 != ((hv_errR1-50)<(hv_ProdR1+5)))
  {
    hv_imgR1 = hv_ProdR1+5;
  }
  else
  {
    hv_imgR1 = hv_errR1-50;
  }
  //
  if (0 != ((hv_errR2+50)>(hv_ProdR2-5)))
  {
    hv_imgR2 = hv_ProdR2-5;
  }
  else
  {
    hv_imgR2 = hv_errR2+50;
  }
  //
  if (0 != ((hv_errC1-50)<(hv_ProdC1+5)))
  {
    hv_imgC1 = hv_ProdC1+5;
  }
  else
  {
    hv_imgC1 = hv_errC1-50;
  }
  //
  if (0 != ((hv_errC2+50)>(hv_ProdC2-5)))
  {
    hv_imgC2 = hv_ProdC2-5;
  }
  else
  {
    hv_imgC2 = hv_errC2+50;
  }
  ////判断小图是否完全在产品区域之内
  GenRectangle1(&ho_imgRect, hv_imgR1, hv_imgC1, hv_imgR2, hv_imgC2);
  ReduceDomain(ho_Image, ho_imgRect, &ho_imgSmall);
  //区域是否包含在另一个区域中
  TestSubsetRegion(ho_InputRegion, ho_DynThreshRegion1, &hv_subSet1);
  TestSubsetRegion(ho_InputRegion, ho_DynThreshRegion2, &hv_subSet2);
  TestSubsetRegion(ho_InputRegion, ho_DynThreshRegion3, &hv_subSet3);
  TestSubsetRegion(ho_InputRegion, ho_DynThreshRegion4, &hv_subSet4);
  //global tuple G_DEEP_REGION
  //global tuple G_SHALLOW_REGION
  //global tuple G_DEEP_REGION2
  //global tuple G_SHALLOW_REGION2

  hv_DEEP_REGION = ExpGetGlobalVar_G_DEEP_REGION();
  hv_SHALLOW_REGION = ExpGetGlobalVar_G_SHALLOW_REGION();
  hv_DEEP_REGION2 = ExpGetGlobalVar_G_DEEP_REGION2();
  hv_SHALLOW_REGION2 = ExpGetGlobalVar_G_SHALLOW_REGION2();


  if (0 != (hv_subSet1>0))
  {
    hv_Features_properDynThresh = hv_DEEP_REGION;
  }
  else if (0 != (hv_subSet2>0))
  {
    hv_Features_properDynThresh = hv_SHALLOW_REGION;
  }
  else if (0 != (hv_subSet3>0))
  {
    hv_Features_properDynThresh = hv_DEEP_REGION2;
  }
  else if (0 != (hv_subSet4>0))
  {
    hv_Features_properDynThresh = hv_SHALLOW_REGION2;
  }
  (*hvec_FeatureVals).Insert((*hvec_FeatureVals).Length(),HTupleVector(HTuple(HTuple("Features_properDynThresh").TupleConcat(hv_Features_properDynThresh))));
  //
  CopyObj(ho_InputRegion, &ho_regionDyn, 1, 1);
  AreaCenter(ho_regionDyn, &hv_regionArea, &hv_NULL, &hv_NULL);
  Intensity(ho_regionDyn, ho_imgSmall, &hv_regionMean, &hv_regionDeviation);
  SmallestRectangle1(ho_regionDyn, &hv_errR1, &hv_errC1, &hv_errR2, &hv_errC2);
  hv_Features_regionWidthPix = (hv_errC2-hv_errC1)+1;
  hv_Features_regionHeightPix = (hv_errR2-hv_errR1)+1;
  (*hvec_FeatureVals).Insert((*hvec_FeatureVals).Length(),HTupleVector(HTuple(HTuple("Features_regionWidthPix").TupleConcat(hv_Features_regionWidthPix))));
  (*hvec_FeatureVals).Insert((*hvec_FeatureVals).Length(),HTupleVector(HTuple(HTuple("Features_regionHeightPix").TupleConcat(hv_Features_regionHeightPix))));
  ////取较大值作为直径
  GetMessageTuple(hv_MessageHandle, "Resolution_H", &hv_Resolution_H);
  GetMessageTuple(hv_MessageHandle, "Resolution_W", &hv_Resolution_W);
  hv_errDiam = (((hv_errR2-hv_errR1)*hv_Resolution_H).TupleConcat((hv_errC2-hv_errC1)*hv_Resolution_W)).TupleMax();
  //

  ////缺陷面积及中心位置
  AreaCenter(ho_regionDyn, &hv_errArea, &hv_errCenterR, &hv_errCenterC);
  hv_Features_errAreaPix = hv_errArea;
  hv_Features_retResults_rectvals.Clear();
  hv_Features_retResults_rectvals.Append(hv_errC1);
  hv_Features_retResults_rectvals.Append(hv_errR1);
  hv_Features_retResults_rectvals.Append(hv_errC2);
  hv_Features_retResults_rectvals.Append(hv_errR2);
  (*hvec_FeatureVals).Insert((*hvec_FeatureVals).Length(),HTupleVector(HTuple(HTuple("Features_errAreaPix").TupleConcat(hv_Features_errAreaPix))));
  (*hvec_FeatureVals).Insert((*hvec_FeatureVals).Length(),HTupleVector(HTuple(HTuple("Features_retResults_rectvals").TupleConcat(hv_Features_retResults_rectvals))));
  GetMessageTuple(hv_MessageHandle, "Surf_Calib2", &hv_Surf_Calib2);
  GetMessageTuple(hv_MessageHandle, "Surf_Calib", &hv_Surf_Calib);
  hv_Features_retResults_ErrorArea = ((hv_errArea*hv_Resolution_W)*hv_Resolution_H)*hv_Surf_Calib2;
  hv_Features_retResults_Diameter = hv_errDiam*hv_Surf_Calib;
  (*hvec_FeatureVals).Insert((*hvec_FeatureVals).Length(),HTupleVector(HTuple(HTuple("Features_retResults_ErrorArea").TupleConcat(hv_Features_retResults_ErrorArea))));
  (*hvec_FeatureVals).Insert((*hvec_FeatureVals).Length(),HTupleVector(HTuple(HTuple("Features_retResults_Diameter").TupleConcat(hv_Features_retResults_Diameter))));
  GetMessageTuple(hv_MessageHandle, "Surf_Area_Min", &hv_Surf_Area_Min);
  if (0 != (hv_Surf_Area_Min>0))
  {
    hv_Features_retResults_nLevel = (hv_errArea/hv_Surf_Area_Min).TupleInt();
  }
  else
  {
    hv_Features_retResults_nLevel = 0;
  }
  //错误程度
  (*hvec_FeatureVals).Insert((*hvec_FeatureVals).Length(),HTupleVector(HTuple(HTuple("Features_retResults_nLevel").TupleConcat(hv_Features_retResults_nLevel))));
  //
  hv_Features_retResults_x = (hv_errCenterC-hv_ProdC1).TupleInt();
  hv_Features_retResults_y = hv_errCenterR.TupleInt();
  //
  (*hvec_FeatureVals).Insert((*hvec_FeatureVals).Length(),HTupleVector(HTuple(HTuple("Features_retResults_x").TupleConcat(hv_Features_retResults_x))));
  (*hvec_FeatureVals).Insert((*hvec_FeatureVals).Length(),HTupleVector(HTuple(HTuple("Features_retResults_y").TupleConcat(hv_Features_retResults_y))));
  //
  ////是否是亮线
  GetMessageTuple(hv_MessageHandle, "Surf_iMinWidthGray", &hv_Surf_iMinWidthGray);
  GetMessageTuple(hv_MessageHandle, "Surf_iMaxWidthGray", &hv_Surf_iMaxWidthGray);
  Threshold(ho_imgSmall, &ho_threshArea, hv_Surf_iMinWidthGray, hv_Surf_iMaxWidthGray);
  Connection(ho_threshArea, &ho_threshArea);
  SmallestRectangle1(ho_threshArea, &hv_threshR1, &hv_threshC1, &hv_threshR2, &hv_threshC2);
  hv_Features_errHeight = (hv_threshR2-hv_threshR1)+1;
  hv_Features_errWidth = (hv_threshC2-hv_threshC1)+1;
  (*hvec_FeatureVals).Insert((*hvec_FeatureVals).Length(),HTupleVector(HTuple(HTuple("Features_errWidth").TupleConcat(hv_Features_errWidth))));
  (*hvec_FeatureVals).Insert((*hvec_FeatureVals).Length(),HTupleVector(HTuple(HTuple("Features_errHeight").TupleConcat(hv_Features_errHeight))));
  //
  //
  //
  //
  //
  //
  GetMessageTuple(hv_MessageHandle, "Surf_ShallowSizePixS2", &hv_Surf_ShallowSizePixS2);
  GetMessageTuple(hv_MessageHandle, "Surf_iRecordWidthLine", &hv_Surf_iRecordWidthLine);
  GetMessageTuple(hv_MessageHandle, "Surf_fHorAndVorRatio", &hv_Surf_fHorAndVorRatio);
  GetMessageTuple(hv_MessageHandle, "Surf_DeepSizePixL2", &hv_Surf_DeepSizePixL2);
  GetMessageTuple(hv_MessageHandle, "Surf_DeepSizePixM2", &hv_Surf_DeepSizePixM2);
  GetMessageTuple(hv_MessageHandle, "Surf_DeepSizePixS2", &hv_Surf_DeepSizePixS2);
  GetMessageTuple(hv_MessageHandle, "Surf_ShallowSizePixL2", &hv_Surf_ShallowSizePixL2);
  GetMessageTuple(hv_MessageHandle, "Surf_ShallowSizePixM2", &hv_Surf_ShallowSizePixM2);
  GetMessageTuple(hv_MessageHandle, "Surf_DeepSizePixL", &hv_Surf_DeepSizePixL);
  GetMessageTuple(hv_MessageHandle, "Surf_DeepSizePixM", &hv_Surf_DeepSizePixM);
  GetMessageTuple(hv_MessageHandle, "Surf_DeepSizePixS", &hv_Surf_DeepSizePixS);
  //
  hv_retClass = "DEFECT";
  if (0 != (hv_DEEP_REGION==hv_Features_properDynThresh))
  {
    //
    if (0 != (hv_Features_errAreaPix>=hv_Surf_DeepSizePixL))
    {
      hv_retClass = "DEEP_L";
      //Features_retResults_ifTag := Surf_IfDeepLTag
    }
    else if (0 != (hv_Features_errAreaPix>=hv_Surf_DeepSizePixM))
    {
      hv_retClass = "DEEP_M";
    }
    else if (0 != (hv_Features_errAreaPix>=hv_Surf_DeepSizePixS))
    {
      hv_retClass = "DEEP_S";
    }
  }
  else if (0 != (hv_DEEP_REGION2==hv_Features_properDynThresh))
  {
    if (0 != (hv_Features_errAreaPix>=hv_Surf_DeepSizePixL2))
    {
      hv_retClass = "DEEP_L2";
    }
    else if (0 != (hv_Features_errAreaPix>=hv_Surf_DeepSizePixM2))
    {
      hv_retClass = "DEEP_M2";
    }
    else if (0 != (hv_Features_errAreaPix>=hv_Surf_DeepSizePixS2))
    {
      hv_retClass = "DEEP_S2";
    }
  }
  else if (0 != (hv_SHALLOW_REGION2==hv_Features_properDynThresh))
  {
    if (0 != (hv_Features_errAreaPix>=hv_Surf_ShallowSizePixL2))
    {
      hv_retClass = "SHALLOW_L2";
    }
    else if (0 != (hv_Features_errAreaPix>=hv_Surf_ShallowSizePixM2))
    {
      hv_retClass = "SHALLOW_M2";
    }
    else if (0 != (hv_Features_errAreaPix>=hv_Surf_ShallowSizePixS2))
    {
      hv_retClass = "SHALLOW_S2";
    }
  }
  TupleInt(hv_Surf_iRecordWidthLine, &hv_Surf_iRecordWidthLine);
  if (0 != (HTuple(((1.0*hv_Features_errWidth)/hv_Features_errHeight)>=hv_Surf_fHorAndVorRatio).TupleAnd(hv_Surf_iRecordWidthLine)))
  {
    hv_retClass = "DEFECT";
  }
  GetMessageTuple(hv_MessageHandle, "LabelNames", &hv_LabelNames);
  TupleFind(hv_LabelNames, hv_retClass, &hv_LabelIndices);
  GetMessageTuple(hv_MessageHandle, "AlarmNames", &hv_AlarmNames);
  TupleFind(hv_LabelNames, hv_retClass, &hv_AlarmIndices);
  if (0 != (HTuple(hv_LabelIndices[0])>=0))
  {
    hv_Features_retResults_ifTag = 1;
  }
  else
  {
    hv_Features_retResults_ifTag = 0;
  }
  if (0 != (HTuple(hv_AlarmIndices[0])>=0))
  {
    hv_Features_retResults_Alarm = 1;
  }
  else
  {
    hv_Features_retResults_Alarm = 0;
  }
  (*hvec_FeatureVals).Insert((*hvec_FeatureVals).Length(),HTupleVector(HTuple(HTuple("Features_retResults_ifTag").TupleConcat(hv_Features_retResults_ifTag))));
  (*hvec_FeatureVals).Insert((*hvec_FeatureVals).Length(),HTupleVector(HTuple(HTuple("Features_retResults_Alarm").TupleConcat(hv_Features_retResults_Alarm))));
  GetMessageTuple(hv_MessageHandle, hv_retClass, &hv_retClass);
  hv_Features_retResults_Errortype = hv_retClass;
  GetMessageTuple(hv_MessageHandle, "DefectNames", &hv_DefectNames);
  GetMessageTuple(hv_MessageHandle, "DefectVals", &hv_DefectVals);
  TupleString(hv_retClass, "#", &hv_retClass);
  TupleFindFirst(hv_DefectNames, hv_retClass, &hv_firstIndex);
  if (0 != ((hv_firstIndex.TupleLength())!=0))
  {
    if (0 != (HTuple(hv_firstIndex[0])<0))
    {
      hv_firstIndex[0] = 0;
    }
    hv_Features_retResults_strErrortype = ((const HTuple&)hv_DefectVals)[HTuple(hv_firstIndex[0])];
    (*hvec_FeatureVals).Insert((*hvec_FeatureVals).Length(),HTupleVector(HTuple(HTuple("Features_retResults_strErrortype").TupleConcat(hv_Features_retResults_strErrortype))));
    (*hvec_FeatureVals).Insert((*hvec_FeatureVals).Length(),HTupleVector(HTuple(HTuple("Features_retResults_Errortype").TupleConcat(hv_Features_retResults_Errortype))));
    (*hvec_FeatureVals).Insert((*hvec_FeatureVals).Length(),HTupleVector(HTuple(HTuple("Features_retResults_ifTag").TupleConcat(hv_Features_retResults_ifTag))));
  }
  //
  //
  //
  //
  return;
}

void Check_Surface (HObject ho_Image, HTuple hv_ShowHide, HTuple hv_WindowHandle, 
    HTuple hv_MessageHandle, HTuple *hv_ResultInfo, HTuple *hv_WindowInfo, HTupleVector/*{eTupleVector,Dim=2}*/ *hvec_FeatureVals)
{

  // Local iconic variables
  HObject  ho_CheckRegion, ho_ImgReduced, ho_ProductRegion;
  HObject  ho_SelectedRegions, ho_RegionReduced, ho_Mean1;
  HObject  ho_Mean2, ho_AlreadySeg, ho_DynThreshRegion, ho_DynThreshRegion1;
  HObject  ho_RegionInput, ho_DynThreshRegion2, ho_DynThreshRegion3;
  HObject  ho_DynThreshRegion4, ho_ProcessRegion, ho_ObjForAsses;

  // Local control variables
  HTuple  hv_AREA_MAX, hv_Area, hv_ImageCenterRow;
  HTuple  hv_ImageCenterCol, hv_Surf_ProdGray_Low, hv_Surf_ProdGray_High;
  HTuple  hv_Surf_CloseW, hv_Surf_CloseH, hv_Surf_EroseW;
  HTuple  hv_Surf_EroseH, hv_Surf_ProdArea, hv_ObjectAmount;
  HTuple  hv_ifContinue, hv_ProdR1, hv_ProdC1, hv_ProdR2;
  HTuple  hv_ProdC2, hv_ImageAsses_Width, hv_ImageAsses_Height;
  HTuple  hv_str_DynMode1, hv_str_DynMode2, hv_str_DynMode3;
  HTuple  hv_str_DynMode4, hv_Surf_MeanW1, hv_Surf_MeanH1;
  HTuple  hv_Surf_MeanW2, hv_Surf_MeanH2, hv_Surf_DynThresh1;
  HTuple  hv_tempThreshArea, hv_NULL, hv_Surf_CloseW1, hv_Surf_CloseH1;
  HTuple  hv_Surf_DeepSizePixS, hv_Surf_DynThresh2, hv_Surf_CloseW2;
  HTuple  hv_Surf_CloseH2, hv_Surf_ShallowSizePixS, hv_Surf_DynThresh3;
  HTuple  hv_Surf_CloseW3, hv_Surf_CloseH3, hv_Surf_DeepSizePixS2;
  HTuple  hv_Surf_DynThresh4, hv_Surf_CloseW4, hv_Surf_CloseH4;
  HTuple  hv_Surf_ShallowSizePixS2, hv_defectArea, hv_temphArea;
  HTuple  hv_temphSortIndex, hv_DefectAmount, hv_MaxReturnNum;
  HTuple  hv_Index;
  HTupleVector  hvec_FeatureVal(1);

  //
  //Features_retResults_nReginType检测区域类型
  //Features_retResults_strReginType检测类型字符串，返回值为“左面”或“右面”
  //Features_retResults_rectval错误区域外界矩形坐标
  //Features_retResults_ErrorType....................................错误类型
  //Features_retResults_strErrortype ....................................//错误类型字符串，返回值为“暗斑”，“干料”等缺陷中文名称
  //Features_retResults_ErrorContrast//缺陷对比度
  //Features_retResults_ErrorArea// 错误面积
  //Features_retResults_Diameter....................................错误面积
  //Features_retResults_Descript字符串描述
  //Features_retResults_nLevel....................................错误程度
  //Features_retResults_x....................................缺陷水平方向坐标
  //Features_retResults_y....................................缺陷垂直方向坐标
  //Features_retResults_fFeature
  //Features_retResults_ifTag....................................是否打标
  //Features_retResults_TagLength....................................打标持续行数
  //
  //Features_properDynThresh....................................
  //Features_regionWidthPix....................................
  //Features_regionHeightPix....................................  //缺陷本身的宽高
  //Features_errAreaPix;   //像素面积
  //Features_sImgLeft, //生成的小图区域
  //Features_sImgRight, //生成的小图区域
  //Features_sImgTop, //生成的小图区域
  //Features_sImgBotton;  //生成的小图区域
  //Features_ifInterWithEdge;   //是否跟边缘区域有交集
  //Features_ifNearEdge; //是否靠近边缘
  //Features_errHeight ....................................
  //Features_errWidth; ....................................分割的大块边缘区域宽高
  //Features_sImageHeight
  //Features_sImageWidth;   //小图区域宽高
  //Features_ifCrowded....................................是否密度过大
  //
  //
  //
  //
  //
  //SurfaceCheck()
  (*hv_ResultInfo) = "";
  (*hv_WindowInfo) = HTuple();
  (*hvec_FeatureVals) = HTupleVector(2);

  //global tuple G_AREA_MAX
  hv_AREA_MAX = ExpGetGlobalVar_G_AREA_MAX().TupleInt();
  //
  GetMessageObj(&ho_CheckRegion, hv_MessageHandle, "hCheckRegion");
  ReduceDomain(ho_Image, ho_CheckRegion, &ho_ImgReduced);
  AreaCenter(ho_CheckRegion, &hv_Area, &hv_ImageCenterRow, &hv_ImageCenterCol);
  //将reduce后的图像进行阈值处理
  GetMessageTuple(hv_MessageHandle, "Surf_ProdGray_Low", &hv_Surf_ProdGray_Low);
  GetMessageTuple(hv_MessageHandle, "Surf_ProdGray_High", &hv_Surf_ProdGray_High);
  Threshold(ho_ImgReduced, &ho_ProductRegion, hv_Surf_ProdGray_Low, hv_Surf_ProdGray_High);
  //
  GetMessageTuple(hv_MessageHandle, "Surf_CloseW", &hv_Surf_CloseW);
  GetMessageTuple(hv_MessageHandle, "Surf_CloseH", &hv_Surf_CloseH);
  ClosingRectangle1(ho_ProductRegion, &ho_ProductRegion, hv_Surf_CloseW, hv_Surf_CloseH);
  FillUp(ho_ProductRegion, &ho_ProductRegion);
  //将切边去掉
  GetMessageTuple(hv_MessageHandle, "Surf_EroseW", &hv_Surf_EroseW);
  GetMessageTuple(hv_MessageHandle, "Surf_EroseH", &hv_Surf_EroseH);
  ErosionRectangle1(ho_ProductRegion, &ho_ProductRegion, hv_Surf_EroseW, hv_Surf_EroseH);
  Connection(ho_ProductRegion, &ho_ProductRegion);
  GetMessageTuple(hv_MessageHandle, "Surf_ProdArea", &hv_Surf_ProdArea);
  SelectShape(ho_ProductRegion, &ho_SelectedRegions, "area", "and", hv_Surf_ProdArea, 
      hv_AREA_MAX);
  CountObj(ho_SelectedRegions, &hv_ObjectAmount);
  if (0 != (hv_ObjectAmount>0))
  {
    //有效图片，继续检测
    hv_ifContinue = 1;
    if (0 != (hv_ObjectAmount>1))
    {
      Union1(ho_SelectedRegions, &ho_SelectedRegions);
    }
    CopyObj(ho_SelectedRegions, &ho_ProductRegion, 1, 1);
    //求产品reducce之后进行一些列处理后的图像的宽度
    SmallestRectangle1(ho_ProductRegion, &hv_ProdR1, &hv_ProdC1, &hv_ProdR2, &hv_ProdC2);
    //重新定位要检测的区域
    ReduceDomain(ho_Image, ho_ProductRegion, &ho_ImgReduced);
    hv_ImageAsses_Width = hv_ProdC2-hv_ProdC1;
    hv_ImageAsses_Height = hv_ProdR2-hv_ProdR1;

    //
    //初始化剩余区域
    CopyObj(ho_ProductRegion, &ho_RegionReduced, 1, 1);
    //
    //***模式选择
    GetMessageTuple(hv_MessageHandle, "str_DynMode1", &hv_str_DynMode1);
    GetMessageTuple(hv_MessageHandle, "str_DynMode2", &hv_str_DynMode2);
    GetMessageTuple(hv_MessageHandle, "str_DynMode3", &hv_str_DynMode3);
    GetMessageTuple(hv_MessageHandle, "str_DynMode4", &hv_str_DynMode4);
    //
    GetMessageTuple(hv_MessageHandle, "Surf_MeanW1", &hv_Surf_MeanW1);
    GetMessageTuple(hv_MessageHandle, "Surf_MeanH1", &hv_Surf_MeanH1);
    MeanImage(ho_ImgReduced, &ho_Mean1, hv_Surf_MeanW1, hv_Surf_MeanH1);
    GetMessageTuple(hv_MessageHandle, "Surf_MeanW2", &hv_Surf_MeanW2);
    GetMessageTuple(hv_MessageHandle, "Surf_MeanH2", &hv_Surf_MeanH2);
    MeanImage(ho_ImgReduced, &ho_Mean2, hv_Surf_MeanW2, hv_Surf_MeanH2);
    //
    GenEmptyObj(&ho_AlreadySeg);
    GenEmptyObj(&ho_DynThreshRegion);
    //
    GetMessageTuple(hv_MessageHandle, "Surf_DynThresh1", &hv_Surf_DynThresh1);
    DynThreshold(ho_Mean1, ho_Mean2, &ho_DynThreshRegion1, hv_Surf_DynThresh1, hv_str_DynMode1);
    FillUp(ho_DynThreshRegion1, &ho_DynThreshRegion1);
    AreaCenter(ho_DynThreshRegion1, &hv_tempThreshArea, &hv_NULL, &hv_NULL);
    if (0 != (hv_tempThreshArea>0))
    {
      GetMessageTuple(hv_MessageHandle, "Surf_CloseW1", &hv_Surf_CloseW1);
      GetMessageTuple(hv_MessageHandle, "Surf_CloseH1", &hv_Surf_CloseH1);
      if (0 != (HTuple(hv_Surf_CloseW1>0).TupleAnd(hv_Surf_CloseH1>0)))
      {
        ClosingRectangle1(ho_DynThreshRegion1, &ho_DynThreshRegion1, hv_Surf_CloseW1, 
            hv_Surf_CloseH1);
      }
      Connection(ho_DynThreshRegion1, &ho_DynThreshRegion1);
      GetMessageTuple(hv_MessageHandle, "Surf_DeepSizePixS", &hv_Surf_DeepSizePixS);
      SelectShape(ho_DynThreshRegion1, &ho_DynThreshRegion1, "area", "and", hv_Surf_DeepSizePixS, 
          hv_AREA_MAX);
      ho_RegionInput = ho_DynThreshRegion1;
      GetRemainRegion(ho_DynThreshRegion1, ho_RegionReduced, ho_AlreadySeg, ho_ProductRegion, 
          ho_DynThreshRegion, &ho_DynThreshRegion1, &ho_AlreadySeg, &ho_RegionReduced, 
          &ho_DynThreshRegion);
      //
    }
    //
    GetMessageTuple(hv_MessageHandle, "Surf_DynThresh2", &hv_Surf_DynThresh2);
    DynThreshold(ho_Mean1, ho_Mean2, &ho_DynThreshRegion2, hv_Surf_DynThresh2, hv_str_DynMode2);
    FillUp(ho_DynThreshRegion2, &ho_DynThreshRegion2);
    AreaCenter(ho_DynThreshRegion2, &hv_tempThreshArea, &hv_NULL, &hv_NULL);
    if (0 != (hv_tempThreshArea>0))
    {
      GetMessageTuple(hv_MessageHandle, "Surf_CloseW2", &hv_Surf_CloseW2);
      GetMessageTuple(hv_MessageHandle, "Surf_CloseH2", &hv_Surf_CloseH2);
      if (0 != (HTuple(hv_Surf_CloseW2>0).TupleAnd(hv_Surf_CloseH2>0)))
      {
        ClosingRectangle1(ho_DynThreshRegion1, &ho_DynThreshRegion1, hv_Surf_CloseW2, 
            hv_Surf_CloseH2);
      }
      Connection(ho_DynThreshRegion2, &ho_DynThreshRegion2);
      GetMessageTuple(hv_MessageHandle, "Surf_ShallowSizePixS", &hv_Surf_ShallowSizePixS);
      SelectShape(ho_DynThreshRegion2, &ho_DynThreshRegion2, "area", "and", hv_Surf_ShallowSizePixS, 
          hv_AREA_MAX);
      GetRemainRegion(ho_DynThreshRegion2, ho_RegionReduced, ho_AlreadySeg, ho_ProductRegion, 
          ho_DynThreshRegion, &ho_DynThreshRegion2, &ho_AlreadySeg, &ho_RegionReduced, 
          &ho_DynThreshRegion);
    }
    //
    GetMessageTuple(hv_MessageHandle, "Surf_DynThresh3", &hv_Surf_DynThresh3);
    DynThreshold(ho_Mean1, ho_Mean2, &ho_DynThreshRegion3, hv_Surf_DynThresh3, hv_str_DynMode3);
    FillUp(ho_DynThreshRegion3, &ho_DynThreshRegion3);
    AreaCenter(ho_DynThreshRegion3, &hv_tempThreshArea, &hv_NULL, &hv_NULL);
    if (0 != (hv_tempThreshArea>0))
    {
      GetMessageTuple(hv_MessageHandle, "Surf_CloseW3", &hv_Surf_CloseW3);
      GetMessageTuple(hv_MessageHandle, "Surf_CloseH3", &hv_Surf_CloseH3);
      if (0 != (HTuple(hv_Surf_CloseW3>0).TupleAnd(hv_Surf_CloseH3>0)))
      {
        ClosingRectangle1(ho_DynThreshRegion3, &ho_DynThreshRegion3, hv_Surf_CloseW3, 
            hv_Surf_CloseH3);
      }
      Connection(ho_DynThreshRegion3, &ho_DynThreshRegion3);
      GetMessageTuple(hv_MessageHandle, "Surf_DeepSizePixS2", &hv_Surf_DeepSizePixS2);
      SelectShape(ho_DynThreshRegion3, &ho_DynThreshRegion3, "area", "and", hv_Surf_DeepSizePixS2, 
          hv_AREA_MAX);
      GetRemainRegion(ho_DynThreshRegion3, ho_RegionReduced, ho_AlreadySeg, ho_ProductRegion, 
          ho_DynThreshRegion, &ho_DynThreshRegion3, &ho_AlreadySeg, &ho_RegionReduced, 
          &ho_DynThreshRegion);
    }
    //
    GetMessageTuple(hv_MessageHandle, "Surf_DynThresh4", &hv_Surf_DynThresh4);
    DynThreshold(ho_Mean1, ho_Mean2, &ho_DynThreshRegion4, hv_Surf_DynThresh4, hv_str_DynMode4);
    FillUp(ho_DynThreshRegion4, &ho_DynThreshRegion4);
    AreaCenter(ho_DynThreshRegion4, &hv_tempThreshArea, &hv_NULL, &hv_NULL);
    if (0 != (hv_tempThreshArea>0))
    {
      GetMessageTuple(hv_MessageHandle, "Surf_CloseW4", &hv_Surf_CloseW4);
      GetMessageTuple(hv_MessageHandle, "Surf_CloseH4", &hv_Surf_CloseH4);
      if (0 != (HTuple(hv_Surf_CloseW4>0).TupleAnd(hv_Surf_CloseH4>0)))
      {
        ClosingRectangle1(ho_DynThreshRegion1, &ho_DynThreshRegion1, hv_Surf_CloseW4, 
            hv_Surf_CloseH4);
      }
      Connection(ho_DynThreshRegion4, &ho_DynThreshRegion4);
      GetMessageTuple(hv_MessageHandle, "Surf_ShallowSizePixS2", &hv_Surf_ShallowSizePixS2);
      SelectShape(ho_DynThreshRegion4, &ho_DynThreshRegion4, "area", "and", hv_Surf_ShallowSizePixS2, 
          hv_AREA_MAX);
      GetRemainRegion(ho_DynThreshRegion4, ho_RegionReduced, ho_AlreadySeg, ho_ProductRegion, 
          ho_DynThreshRegion, &ho_DynThreshRegion4, &ho_AlreadySeg, &ho_RegionReduced, 
          &ho_DynThreshRegion);
    }
  }
  Connection(ho_DynThreshRegion, &ho_ProcessRegion);
  //
  //
  ///*将检测出的区域联合到一起*/
  Union1(ho_DynThreshRegion1, &ho_DynThreshRegion1);
  Union1(ho_DynThreshRegion2, &ho_DynThreshRegion2);
  Union1(ho_DynThreshRegion3, &ho_DynThreshRegion3);
  Union1(ho_DynThreshRegion4, &ho_DynThreshRegion4);
  AreaCenter(ho_DynThreshRegion, &hv_defectArea, &hv_NULL, &hv_NULL);
  if (0 != (hv_defectArea>0))
  {
    AreaCenter(ho_ProcessRegion, &hv_temphArea, &hv_NULL, &hv_NULL);
    TupleSortIndex(hv_temphArea, &hv_temphSortIndex);
    TupleInverse(hv_temphSortIndex, &hv_temphSortIndex);
    CountObj(ho_ProcessRegion, &hv_DefectAmount);
    GetMessageTuple(hv_MessageHandle, "MaxReturnNum", &hv_MaxReturnNum);
    (*hvec_FeatureVals) = HTupleVector(2);
    {
    HTuple end_val181 = ((hv_DefectAmount.TupleConcat(hv_MaxReturnNum)).TupleMin())-1;
    HTuple step_val181 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val181, step_val181); hv_Index += step_val181)
    {
      ////逐一选中区域进行分析
      SelectObj(ho_ProcessRegion, &ho_ObjForAsses, HTuple(hv_temphSortIndex[hv_Index])+1);
      hvec_FeatureVal = HTupleVector(1);
      CalculateFeatures(ho_ObjForAsses, ho_Image, ho_DynThreshRegion1, ho_DynThreshRegion2, 
          ho_DynThreshRegion3, ho_DynThreshRegion4, hv_ProdR1, hv_ProdR2, hv_ProdC1, 
          hv_ProdC2, hv_MessageHandle, &hvec_FeatureVal);
      (*hvec_FeatureVals).Insert(hv_Index,hvec_FeatureVal);
    }
    }
  }
  if (0 != hv_ShowHide)
  {
    DispObj(ho_ProcessRegion, hv_WindowHandle);
  }
  //
  //
  return;
}

void GetRemainRegion (HObject ho_RegionInput, HObject ho_RegionReduced, HObject ho_AlreadySeg, 
    HObject ho_ProductRegion, HObject ho_DynThreshRegion, HObject *ho_RegionInputOut, 
    HObject *ho_AlreadySegOut, HObject *ho_RegionReducedOut, HObject *ho_DynThreshRegionOut)
{

  // Local iconic variables
  HObject  ho_TempDilationRegion, ho_RegionLeft;

  // Local control variables
  HTuple  hv_inputArea, hv_NULL, hv_tempInputArea;
  HTuple  hv_tempAlreadySegArea, hv_tempRegionLeftArea, hv_tempDynThreshRegionArea;

  (*ho_AlreadySegOut) = ho_AlreadySeg;
  (*ho_DynThreshRegionOut) = ho_DynThreshRegion;
  (*ho_RegionInputOut) = ho_RegionInput;
  (*ho_RegionReducedOut) = ho_RegionReduced;
  Union1((*ho_RegionInputOut), &(*ho_RegionInputOut));
  AreaCenter((*ho_RegionInputOut), &hv_inputArea, &hv_NULL, &hv_NULL);
  if (0 != (hv_inputArea>0))
  {
    Intersection((*ho_RegionReducedOut), (*ho_RegionInputOut), &(*ho_RegionInputOut)
        );
    AreaCenter((*ho_RegionInputOut), &hv_tempInputArea, &hv_NULL, &hv_NULL);
    if (0 != (hv_tempInputArea>0))
    {
      DilationRectangle1((*ho_RegionInputOut), &ho_TempDilationRegion, 50, 50);
      AreaCenter((*ho_AlreadySegOut), &hv_tempAlreadySegArea, &hv_NULL, &hv_NULL);
      if (0 != (hv_tempAlreadySegArea>0))
      {
        ConcatObj(ho_TempDilationRegion, (*ho_AlreadySegOut), &(*ho_AlreadySegOut)
            );
        Union1((*ho_AlreadySegOut), &(*ho_AlreadySegOut));
      }
      else
      {
        CopyObj(ho_TempDilationRegion, &(*ho_AlreadySegOut), 1, 1);
      }
      AreaCenter((*ho_AlreadySegOut), &hv_tempAlreadySegArea, &hv_NULL, &hv_NULL);
      ////4. 更新剩余区域
      Complement((*ho_AlreadySegOut), &ho_RegionLeft);
      AreaCenter(ho_RegionLeft, &hv_tempRegionLeftArea, &hv_NULL, &hv_NULL);
      if (0 != (hv_tempRegionLeftArea>0))
      {
        Intersection(ho_ProductRegion, ho_RegionLeft, &(*ho_RegionReducedOut));
      }
      AreaCenter((*ho_DynThreshRegionOut), &hv_tempDynThreshRegionArea, &hv_NULL, 
          &hv_NULL);
      if (0 != (hv_tempDynThreshRegionArea>0))
      {
        ConcatObj((*ho_RegionInputOut), (*ho_DynThreshRegionOut), &(*ho_DynThreshRegionOut)
            );
      }
      else
      {
        CopyObj((*ho_RegionInputOut), &(*ho_DynThreshRegionOut), 1, 1);
      }
    }
    //
  }
  Connection((*ho_RegionInputOut), &(*ho_RegionInputOut));
  return;
}

void InitSurCheck (HTuple hv_MessageHandle)
{

  // Local iconic variables
  HObject  ho_hCheckRegion;

  // Local control variables
  HTuple  hv_TestName, hv_CameraIndex, hv_ImageW;
  HTuple  hv_ImageH, hv_DirName, hv_CheckParam, hv_CurrentSchemePath;
  HTuple  hv_CurrentScheme, hv_SystemPath, hv_val, hv_Default_DEFECT;
  HTuple  hv_DEEP_S, hv_DEEP_M, hv_DEEP_L, hv_SHALLOW_S, hv_SHALLOW_M;
  HTuple  hv_SHALLOW_L, hv_OVER_CROWDED, hv_DEEP_S2, hv_DEEP_M2;
  HTuple  hv_DEEP_L2, hv_SHALLOW_S2, hv_SHALLOW_M2, hv_SHALLOW_L2;
  HTuple  hv_LabelNames, hv_AlarmNames, hv_str_DynMode1, hv_str_DynMode2;
  HTuple  hv_str_DynMode, hv_ImgLeftOffset, hv_ImgRightOffset;

  //

  //
  //表面缺陷类型  OTHER还是0
  //
  //
  GetMessageTuple(hv_MessageHandle, "TestName", &hv_TestName);
  GetMessageTuple(hv_MessageHandle, "CameraIndex", &hv_CameraIndex);
  GetMessageTuple(hv_MessageHandle, "ImageW", &hv_ImageW);
  GetMessageTuple(hv_MessageHandle, "ImageH", &hv_ImageH);
  //
  GetCurrentDir(&hv_DirName);
  SetMessageTuple(hv_MessageHandle, "DirName", hv_DirName);
  GetMessageTuple(hv_MessageHandle, "CheckParam", &hv_CheckParam);
  GetMessageTuple(hv_MessageHandle, "CurrentSchemePath", &hv_CurrentSchemePath);
  GetMessageTuple(hv_MessageHandle, "CurrentScheme", &hv_CurrentScheme);
  GetMessageTuple(hv_MessageHandle, "SystemPath", &hv_SystemPath);
  //
  //
  //

  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "边缘检测", 
      "边缘面积", "EdgeArea", 50, &hv_val);
  //
  //[缺陷类型]
  //
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷类型", 
      "默认", "DEFECT", 10, &hv_Default_DEFECT);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷类型", 
      "DEEP_S", "DEEP_S", 11, &hv_DEEP_S);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷类型", 
      "DEEP_M", "DEEP_M", 12, &hv_DEEP_M);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷类型", 
      "DEEP_L", "DEEP_L", 13, &hv_DEEP_L);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷类型", 
      "SHALLOW_S", "SHALLOW_S", 14, &hv_SHALLOW_S);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷类型", 
      "SHALLOW_M", "SHALLOW_M", 15, &hv_SHALLOW_M);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷类型", 
      "SHALLOW_L", "SHALLOW_L", 16, &hv_SHALLOW_L);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷类型", 
      "OVER_CROWDED", "OVER_CROWDED", 17, &hv_OVER_CROWDED);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷类型", 
      "DEEP_S2", "DEEP_S2", 18, &hv_DEEP_S2);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷类型", 
      "DEEP_M2", "DEEP_M2", 19, &hv_DEEP_M2);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷类型", 
      "DEEP_L2", "DEEP_L2", 20, &hv_DEEP_L2);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷类型", 
      "SHALLOW_S2", "SHALLOW_S2", 21, &hv_SHALLOW_S2);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷类型", 
      "SHALLOW_M2", "SHALLOW_M2", 22, &hv_SHALLOW_M2);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷类型", 
      "SHALLOW_L2", "SHALLOW_L2", 23, &hv_SHALLOW_L2);
  //
  //[打标报警]
  load_config(hv_CurrentScheme, "缺陷类型_打标报警", "打标", "DEEP_S|DEEP_M|DEEP_L|", 
      &hv_LabelNames);
  load_config(hv_CurrentScheme, "缺陷类型_打标报警", "报警", "DEEP_S|DEEP_M|DEEP_L|", 
      &hv_AlarmNames);
  tuple_regexp_replace_all(hv_LabelNames, " ", "", &hv_LabelNames);
  TupleSplit(hv_LabelNames, "|", &hv_LabelNames);
  tuple_regexp_replace_all(hv_AlarmNames, " ", "", &hv_AlarmNames);
  TupleSplit(hv_AlarmNames, "|", &hv_AlarmNames);
  SetMessageTuple(hv_MessageHandle, "AlarmNames", hv_AlarmNames);
  SetMessageTuple(hv_MessageHandle, "LabelNames", hv_LabelNames);
  //
  //
  //[测宽]
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "测宽", "测宽灰度", 
      "WidthGray", 0, &hv_val);
  ////
  //[背景分离]
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "背景分离", 
      "产品灰度>", "Surf_ProdGray_Low", 1, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "背景分离", 
      "产品灰度<", "Surf_ProdGray_High", 255, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "背景分离", 
      "产品面积>", "Surf_ProdArea", 2000, &hv_val);
  //[缺陷识别]
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "MeanW1", "Surf_MeanW1", 3, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "MeanH1", "Surf_MeanH1", 3, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "MeanW2", "Surf_MeanW2", 30, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "MeanH2", "Surf_MeanH2", 30, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "CloseW", "Surf_CloseW", 10, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "CloseH", "Surf_CloseH", 1, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "EroseW", "Surf_EroseW", 7, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "EroseH", "Surf_EroseH", 1, &hv_val);
  //
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "DynThresh1", "Surf_DynThresh1", 7, &hv_val);
  switch (hv_val[0].I())
  {
  case 0:
    hv_str_DynMode1 = "light";
    break;
  case 1:
    hv_str_DynMode1 = "dark";
    break;
  case 2:
    hv_str_DynMode1 = "not_equal";
    break;
  default:
    hv_str_DynMode1 = "not_equal";
    break;
  }
  SetMessageTuple(hv_MessageHandle, "str_DynMode1", hv_str_DynMode1);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "CloseW2", "Surf_CloseW1", 20, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "CloseH2", "Surf_CloseH1", 30, &hv_val);
  //
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "DynThresh2", "Surf_DynThresh2", 20, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "DynMode2", "Surf_DynMode2", 30, &hv_val);
  switch (hv_val[0].I())
  {
  case 0:
    hv_str_DynMode2 = "light";
    break;
  case 1:
    hv_str_DynMode2 = "dark";
    break;
  case 2:
    hv_str_DynMode2 = "not_equal";
    break;
  default:
    hv_str_DynMode2 = "not_equal";
    break;
  }
  SetMessageTuple(hv_MessageHandle, "str_DynMode2", hv_str_DynMode2);
  //
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "CloseW2", "Surf_CloseW2", 20, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "CloseH2", "Surf_CloseH2", 30, &hv_val);
  //
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "DynThresh3", "Surf_DynThresh3", 20, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "DynMode3", "Surf_DynMode3", 30, &hv_val);
  switch (hv_val[0].I())
  {
  case 0:
    hv_str_DynMode = "light";
    break;
  case 1:
    hv_str_DynMode = "dark";
    break;
  case 2:
    hv_str_DynMode = "not_equal";
    break;
  default:
    hv_str_DynMode = "not_equal";
    break;
  }
  SetMessageTuple(hv_MessageHandle, "str_DynMode3", hv_str_DynMode);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "CloseW3", "Surf_CloseW3", 20, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "CloseH3", "Surf_CloseH3", 30, &hv_val);
  //
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "DynThresh4", "Surf_DynThresh4", 20, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "DynMode4", "Surf_DynMode4", 30, &hv_val);
  switch (hv_val[0].I())
  {
  case 0:
    hv_str_DynMode = "light";
    break;
  case 1:
    hv_str_DynMode = "dark";
    break;
  case 2:
    hv_str_DynMode = "not_equal";
    break;
  default:
    hv_str_DynMode = "not_equal";
    break;
  }
  SetMessageTuple(hv_MessageHandle, "str_DynMode4", hv_str_DynMode);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "CloseW4", "Surf_CloseW4", 20, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "CloseH4", "Surf_CloseH4", 30, &hv_val);
  //
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "Close_WC5", "Surf_Close_WC5", 0, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "Close_HC5", "Surf_Close_HC5", 0, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "Stripe_W1", "Surf_Stripe_W1", 0, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "Stripe_W2", "Surf_Stripe_W2", 0, &hv_val);
  //
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "Stripe_H1", "Surf_Stripe_H1", 0, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷识别", 
      "Stripe_H2", "Surf_Stripe_H2", 0, &hv_val);
  //
  //
  ////[缺陷尺寸]
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷尺寸", 
      "最小面积", "Surf_Area_Min", 1, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷尺寸", 
      "深缺陷阈值", "Surf_Thresh_Deep", 21, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷尺寸", 
      "深小像素", "Surf_DeepSizePixS", 1, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷尺寸", 
      "深中像素", "Surf_DeepSizePixM", 55, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷尺寸", 
      "深大像素", "Surf_DeepSizePixL", 65, &hv_val);
  //
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷尺寸", 
      "浅缺陷阈值", "Surf_Thresh_Shallow", 22, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷尺寸", 
      "浅小像素", "Surf_ShallowSizePixS", 1, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷尺寸", 
      "浅中像素", "Surf_ShallowSizePixM", 60, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷尺寸", 
      "浅大像素", "Surf_ShallowSizePixL", 100, &hv_val);
  //
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷尺寸", 
      "深缺陷阈值2", "Surf_Thresh_Deep2", 21, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷尺寸", 
      "深小像素2", "Surf_DeepSizePixS2", 1, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷尺寸", 
      "深中像素2", "Surf_DeepSizePixM2", 55, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷尺寸", 
      "深大像素2", "Surf_DeepSizePixL2", 65, &hv_val);
  //
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷尺寸", 
      "浅缺陷阈值2", "Surf_Thresh_Shallow2", 22, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷尺寸", 
      "浅小像素2", "Surf_ShallowSizePixS2", 1, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷尺寸", 
      "浅中像素2", "Surf_ShallowSizePixM2", 60, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷尺寸", 
      "浅大像素2", "Surf_ShallowSizePixL2", 100, &hv_val);
  //
  ////[缺陷评分]
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷评分", 
      "深小评分", "Surf_DeepScoreS", 1, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷评分", 
      "深中评分", "Surf_DeepScoreM", 2, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷评分", 
      "深大评分", "Surf_DeepScoreL", 3, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷评分", 
      "浅小评分", "Surf_ShallowScoreS", 1, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷评分", 
      "浅中评分", "Surf_ShallowScoreM", 2, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷评分", 
      "浅大评分", "Surf_ShallowScoreL", 3, &hv_val);
  //
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷评分", 
      "深小评分2", "Surf_DeepScoreS2", 1, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷评分", 
      "深中评分2", "Surf_DeepScoreM2", 2, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷评分", 
      "深大评分2", "Surf_DeepScoreL2", 3, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷评分", 
      "浅小评分2", "Surf_ShallowScoreS2", 1, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷评分", 
      "浅中评分2", "Surf_ShallowScoreM2", 2, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷评分", 
      "浅大评分2", "Surf_ShallowScoreL2", 3, &hv_val);
  //
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷评分", 
      "竖向暗纹评分", "Surf_VertLineScore", 0, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷评分", 
      "横向暗纹评分", "Surf_HorLineScore", 0, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "缺陷评分", 
      "缺陷总分", "Surf_TotalScore", 1, &hv_val);
  //
  //
  //
  //
  ////[校准]
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "校准", "直径校准", 
      "Surf_Calib", 1.0, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "校准", "面积校准", 
      "Surf_Calib2", 1.0, &hv_val);
  //
  ////[亮线干扰]
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "亮线干扰", 
      "亮线横纵比", "Surf_fHorAndVorRatio", 1.0, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "亮线干扰", 
      "亮线去除", "Surf_iRecordWidthLine", 1.0, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "亮线干扰", 
      "亮线低灰度值", "Surf_iMinWidthGray", 1.0, &hv_val);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "亮线干扰", 
      "亮线高灰度值", "Surf_iMaxWidthGray", 1.0, &hv_val);
  //
  //
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "边界", "左边界", 
      "ImgLeftOffset", 0, &hv_ImgLeftOffset);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, "边界", "右边界"+hv_CameraIndex, 
      "ImgRightOffset", 3746, &hv_ImgRightOffset);
  GenRectangle1(&ho_hCheckRegion, 0, hv_ImgLeftOffset, hv_ImageH, hv_ImgRightOffset);
  SetMessageObj(ho_hCheckRegion, hv_MessageHandle, "hCheckRegion");
  //
  //
  //
  //
  //
  return;
}

void load_config_keys_vals (HTuple hv_IniFile, HTuple hv_SectionName, HTuple *hv_KeyNames, 
    HTuple *hv_KeyVals)
{

  // Local control variables
  HTuple  hv_AlarmFlagNameVals, hv_Sequence;

  ExConfigIniReadKeyNames(hv_IniFile, hv_SectionName, &hv_AlarmFlagNameVals);
  TupleString(hv_AlarmFlagNameVals, "#", &hv_AlarmFlagNameVals);
  TupleSplit(hv_AlarmFlagNameVals, "=", &hv_AlarmFlagNameVals);
  TupleGenSequence(0, (hv_AlarmFlagNameVals.TupleLength())-1, 2, &hv_Sequence);
  TupleSelect(hv_AlarmFlagNameVals, hv_Sequence, &(*hv_KeyNames));
  TupleGenSequence(1, (hv_AlarmFlagNameVals.TupleLength())-1, 2, &hv_Sequence);
  TupleSelect(hv_AlarmFlagNameVals, hv_Sequence, &(*hv_KeyVals));
  //
  return;
}

void Check_OCR (HObject ho_Image, HTuple hv_ShowHide, HTuple hv_WindowHandle, HTuple hv_MessageHandle, 
    HTuple *hv_ResultInfo, HTuple *hv_WindowInfo, HTupleVector/*{eTupleVector,Dim=2}*/ *hvec_FeatureVals)
{

  // Local iconic variables
  HObject  ho_PreprocessingRegion, ho_ImageReduced;
  HObject  ho_ImagePart, ho_ImageResult;

  // Local control variables
  HTuple  hv_Width, hv_Height, hv_PosRowMax, hv_PosRowMin;
  HTuple  hv_ImageAdd, hv_OCRSigns, hv_Width1, hv_Height1;
  HTuple  hv_PyImageInfo, hv_PyThreadID, hv_PyResultVal, hv_isFindOCR1;
  HTuple  hv_OcrWindowInfo1, hv_isFindOCR2, hv_OcrWindowInfo2;
  HTuple  hv_PyResultInfo, hv_PyWindowInfo, hv_Exception;
  HTuple  hv_msg, hv_Index;
  HTupleVector  hvec_PyFeatureVals(2);

  // +++ Threading variables 
  HDevThread*         hcppthread_handle;
  HDevThreadContext   hcppthread_context; // <-signals begin of procedure

  (*hv_ResultInfo) = "OK";
  (*hv_WindowInfo) = HTuple();
  (*hvec_FeatureVals) = HTupleVector(2);


  GetImageSize(ho_Image, &hv_Width, &hv_Height);
  GetMessageTuple(hv_MessageHandle, "PosRowMax", &hv_PosRowMax);
  GetMessageTuple(hv_MessageHandle, "PosRowMin", &hv_PosRowMin);
  GenRectangle1(&ho_PreprocessingRegion, hv_PosRowMin, 0, hv_PosRowMax, hv_Width);

  if (0 != hv_ShowHide)
  {
    DispObj(ho_PreprocessingRegion, hv_WindowHandle);
  }
  ReduceDomain(ho_Image, ho_PreprocessingRegion, &ho_ImageReduced);
  GetMessageTuple(hv_MessageHandle, "ImageAdd", &hv_ImageAdd);
  CropDomain(ho_ImageReduced, &ho_ImagePart);


  AddImage(ho_ImageReduced, ho_ImageReduced, &ho_Image, hv_ImageAdd, 0);

  GetMessageTuple(hv_MessageHandle, "OCRSigns", &hv_OCRSigns);

  GetImageSize(ho_ImagePart, &hv_Width1, &hv_Height1);
  hv_PyImageInfo.Clear();
  hv_PyImageInfo.Append(hv_PosRowMin.TupleInt());
  hv_PyImageInfo.Append(0);
  hv_PyImageInfo.Append(hv_PosRowMax.TupleInt());
  hv_PyImageInfo.Append(hv_Width.TupleInt());

  // Create a thread instance
  hcppthread_handle = new HDevThread(hcppthread_context,
              (void*)HDevExportCpp::_hcppthread_Py_Memory_Check,7,2);
  // Set thread procedure call arguments 
  hcppthread_handle->SetInputIconicParamObject(0,ho_ImagePart);
  hcppthread_handle->SetInputCtrlParamTuple(1,hv_MessageHandle);
  hcppthread_handle->SetInputCtrlParamTuple(2,hv_WindowHandle);
  hcppthread_handle->SetInputCtrlParamTuple(3,hv_ShowHide);
  hcppthread_handle->SetInputCtrlParamTuple(4,hv_Width1);
  hcppthread_handle->SetInputCtrlParamTuple(5,hv_Height1);
  hcppthread_handle->SetInputCtrlParamTuple(6,hv_PyImageInfo);
  hcppthread_handle->BindOutputIconicParamObject(0,0,&ho_ImageResult);
  hcppthread_handle->BindOutputCtrlParamTuple(1,0,&hv_PyResultVal);

  // Start proc line in thread
  hcppthread_handle->ParStart(&hv_PyThreadID);


  OCR_Find(ho_ImageReduced, ho_Image, hv_ShowHide, hv_WindowHandle, hv_MessageHandle, 
      HTuple(hv_OCRSigns[0]), hv_Width, hv_Height, &hv_isFindOCR1, &hv_OcrWindowInfo1);

  OCR_Find(ho_ImageReduced, ho_Image, hv_ShowHide, hv_WindowHandle, hv_MessageHandle, 
      HTuple(hv_OCRSigns[1]), hv_Width, hv_Height, &hv_isFindOCR2, &hv_OcrWindowInfo2);



  //par_join ([PyThreadID,OCRThreadID1,OCRThreadID2])
  HDevThread::ParJoin(hv_PyThreadID);
  GetPyFeature(ho_ImageResult, hv_MessageHandle, hv_ShowHide, hv_WindowHandle, hv_PyResultVal, 
      &hv_PyResultInfo, &hv_PyWindowInfo, &hvec_PyFeatureVals);
  try
  {
    if (0 != (HTuple(hv_isFindOCR1==1).TupleAnd(hv_isFindOCR2==1)))
    {
      (*hv_ResultInfo) = hv_PyResultInfo;
    }
    else
    {
      (*hv_ResultInfo) = "NG";
    }

  }
  // catch (Exception) 
  catch (HalconCpp::HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);

    (*hv_ResultInfo) = "NG";
  }
  hv_msg = "Ai_信息";
  {
  HTuple end_val48 = (hv_PyImageInfo.TupleLength())-1;
  HTuple step_val48 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val48, step_val48); hv_Index += step_val48)
  {
    hv_msg = (hv_msg+",")+HTuple(hv_PyImageInfo[hv_Index]);
  }
  }
  (*hv_WindowInfo).Clear();
  (*hv_WindowInfo).Append(hv_msg);
  (*hv_WindowInfo).Append(hv_OcrWindowInfo1);
  (*hv_WindowInfo).Append(hv_OcrWindowInfo2);
  (*hv_WindowInfo).Append(hv_PyWindowInfo);
  (*hvec_FeatureVals) = hvec_PyFeatureVals;

  hvec_PyFeatureVals = HTupleVector(2);




  return;
}

void MessageExit (HTuple hv_MessageHandle, HTuple hv_MessageKey, HTuple hv_SetVal, 
    HTuple *hv_IsExit)
{


  GetMessageParam(hv_MessageHandle, "key_exists", hv_MessageKey, &(*hv_IsExit));
  if (0 != ((*hv_IsExit)==1))
  {
    throw HalconCpp::HException(("MessageHandle:key:"+hv_MessageKey)+"已经存在");
  }
  SetMessageTuple(hv_MessageHandle, hv_MessageKey, hv_SetVal);
  return;
}

void tuple_regexp_replace_all (HTuple hv_Data, HTuple hv_Expression, HTuple hv_Replace, 
    HTuple *hv_DataOut)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Position;

  (*hv_DataOut) = hv_Data;
  while (0 != 1)
  {
    TupleRegexpReplace((*hv_DataOut), hv_Expression, hv_Replace, &(*hv_DataOut));
    TupleStrchr((*hv_DataOut), " ", &hv_Position);
    if (0 != (hv_Position<0))
    {
      break;
    }
  }
  return;
}

void Init_FloorCheck (HTuple hv_CurrentScheme, HTuple hv_CheckParam, HTuple hv_MessageHandle)
{





  return;
}

void loglog (HTuple hv_MessageInHandle, HTuple hv_NewCreate, HTuple hv_logtxt)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_logtxtOut, hv_MSecond, hv_Second, hv_Minute;
  HTuple  hv_Hour, hv_Day, hv_YDay, hv_Month, hv_Year, hv_GenParamValue;
  HTuple  hv_logFileHandle, hv_String, hv_TestName, hv_logPathName;
  HTuple  hv_FileExists, hv_BaseName, hv_Extension, hv_Directory;
  HTuple  hv_Substrings, hv_Path, hv_systime, hv_String1;
  HTuple  hv_Exception;

  try
  {
    hv_logtxtOut = hv_logtxt;
    TupleString(hv_logtxtOut, "#", &hv_logtxtOut);
    hv_logtxtOut = hv_logtxtOut.TupleSum();
    GetSystemTime(&hv_MSecond, &hv_Second, &hv_Minute, &hv_Hour, &hv_Day, &hv_YDay, 
        &hv_Month, &hv_Year);
    if (0 != hv_NewCreate)
    {
      GetMessageParam(hv_MessageInHandle, "key_exists", "logTime", &hv_GenParamValue);
      if (0 != (hv_GenParamValue==1))
      {
        GetMessageTuple(hv_MessageInHandle, "logFileHandle", &hv_logFileHandle);
        CloseFile(hv_logFileHandle);
      }
      SetMessageTuple(hv_MessageInHandle, "logTime", ((hv_Year.TupleConcat(hv_Month)).TupleConcat(hv_Day)).TupleConcat(hv_Hour));
      TupleString((((((hv_Year.TupleConcat(hv_Month)).TupleConcat(hv_Day)).TupleConcat(hv_Hour)).TupleConcat(hv_Minute)).TupleConcat(hv_Second)).TupleConcat(hv_MSecond), 
          "#", &hv_String);
      GetMessageTuple(hv_MessageInHandle, "TestName", &hv_TestName);
      hv_logPathName = ((("CheckLog/"+hv_TestName)+"/")+(hv_String.TupleSum()))+".cvs";
      FileExists(hv_logPathName, &hv_FileExists);
      if (0 != (hv_FileExists==0))
      {
        parse_filename(hv_logPathName, &hv_BaseName, &hv_Extension, &hv_Directory);
        TupleSplit(hv_Directory, "/", &hv_Substrings);
        create_nodes(hv_Substrings, &hv_Path);
      }
      OpenFile(hv_logPathName, "output", &hv_logFileHandle);
      SetMessageTuple(hv_MessageInHandle, "logFileHandle", hv_logFileHandle);
      FwriteString(hv_logFileHandle, hv_logtxtOut);
      FnewLine(hv_logFileHandle);
    }
    else
    {
      GetMessageParam(hv_MessageInHandle, "key_exists", "logTime", &hv_GenParamValue);
      //
      if (0 != (hv_GenParamValue==0))
      {
        SetMessageTuple(hv_MessageInHandle, "logTime", ((hv_Year.TupleConcat(hv_Month)).TupleConcat(hv_Day)).TupleConcat(hv_Hour));
        TupleString((((((hv_Year.TupleConcat(hv_Month)).TupleConcat(hv_Day)).TupleConcat(hv_Hour)).TupleConcat(hv_Minute)).TupleConcat(hv_Second)).TupleConcat(hv_MSecond), 
            "#", &hv_String);
        //
        GetMessageTuple(hv_MessageInHandle, "TestName", &hv_TestName);
        hv_logPathName = ((("CheckLog/"+hv_TestName)+"/")+(hv_String.TupleSum()))+".cvs";
        FileExists(hv_logPathName, &hv_FileExists);
        if (0 != (hv_FileExists==0))
        {
          parse_filename(hv_logPathName, &hv_BaseName, &hv_Extension, &hv_Directory);
          TupleSplit(hv_Directory, "/", &hv_Substrings);
          create_nodes(hv_Substrings, &hv_Path);
        }
        OpenFile(hv_logPathName, "output", &hv_logFileHandle);
        SetMessageTuple(hv_MessageInHandle, "logFileHandle", hv_logFileHandle);
        FwriteString(hv_logFileHandle, hv_logtxtOut);
        FnewLine(hv_logFileHandle);
      }
      else
      {
        GetMessageTuple(hv_MessageInHandle, "logTime", &hv_systime);
        TupleString(hv_systime, "#", &hv_String1);
        TupleString((((((hv_Year.TupleConcat(hv_Month)).TupleConcat(hv_Day)).TupleConcat(hv_Hour)).TupleConcat(hv_Minute)).TupleConcat(hv_Second)).TupleConcat(hv_MSecond), 
            "#", &hv_String);
        if (0 != ((hv_String1.TupleSelectRange(0,3))!=(hv_String.TupleSelectRange(0,3))))
        {
          GetMessageTuple(hv_MessageInHandle, "logFileHandle", &hv_logFileHandle);
          CloseFile(hv_logFileHandle);
          GetMessageTuple(hv_MessageInHandle, "TestName", &hv_TestName);
          hv_logPathName = ((("CheckLog/"+hv_TestName)+"/")+(hv_String.TupleSum()))+".cvs";
          FileExists(hv_logPathName, &hv_FileExists);
          if (0 != (hv_FileExists==0))
          {
            //
            parse_filename(hv_logPathName, &hv_BaseName, &hv_Extension, &hv_Directory);
            TupleSplit(hv_Directory, "/", &hv_Substrings);
            create_nodes(hv_Substrings, &hv_Path);
          }
          SetMessageTuple(hv_MessageInHandle, "logTime", ((hv_Year.TupleConcat(hv_Month)).TupleConcat(hv_Day)).TupleConcat(hv_Hour));
          OpenFile(hv_logPathName, "output", &hv_logFileHandle);
          SetMessageTuple(hv_MessageInHandle, "logFileHandle", hv_logFileHandle);
          FwriteString(hv_logFileHandle, hv_logtxtOut);
          FnewLine(hv_logFileHandle);
        }
        else
        {
          GetMessageTuple(hv_MessageInHandle, "logFileHandle", &hv_logFileHandle);
          FwriteString(hv_logFileHandle, hv_logtxtOut);
          FnewLine(hv_logFileHandle);
        }
      }
    }
    //
  }
  // catch (Exception) 
  catch (HalconCpp::HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
  }
  //
  return;
}

void get_message_tuple_romove (HTuple hv_MessageHandle, HTuple hv_Key, HTuple *hv_TupleData)
{

  GetMessageTuple(hv_MessageHandle, hv_Key, &(*hv_TupleData));
  SetMessageParam(hv_MessageHandle, "remove_key", hv_Key, HTuple());
  //
  return;
}

void load_config_ValByType (HTuple hv_FileName, HTuple hv_Section, HTuple hv_KeyName, 
    HTuple hv_KeyType, HTuple hv_Defaultval, HTuple *hv_OutData)
{

  Set_DefaultVal_To_ini(hv_FileName, hv_Section, hv_KeyName+"_数据类型", hv_KeyType);
  load_config(hv_FileName, hv_Section, hv_KeyName, hv_Defaultval, &(*hv_OutData));
  return;
}

void load_config_number (HTuple hv_ParamSettingsFile, HTuple hv_section, HTuple hv_key, 
    HTuple hv_Defaultval, HTuple *hv_val)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_FileExists, hv_BaseName, hv_Extension;
  HTuple  hv_Directory, hv_Substrings, hv_Path, hv_String;

  (*hv_val) = "";
  FileExists(hv_ParamSettingsFile, &hv_FileExists);
  if (0 != (hv_FileExists==0))
  {
    parse_filename(hv_ParamSettingsFile, &hv_BaseName, &hv_Extension, &hv_Directory);
    TupleSplit(hv_Directory, "/", &hv_Substrings);
    create_nodes(hv_Substrings, &hv_Path);
    //write_tuple (Defaultval, ParamSettingsFile)
    ExConfigIniCreate(hv_ParamSettingsFile);
  }
  else
  {
    ExConfigIniReadStr(hv_ParamSettingsFile, hv_section, hv_key, "", &(*hv_val));
  }
  if (0 != ((*hv_val)==HTuple("")))
  {
    TupleString(hv_Defaultval, "#", &hv_String);
    ExConfigIniWriteStr(hv_ParamSettingsFile, hv_section, hv_key, hv_String);
    (*hv_val) = hv_Defaultval;
  }
  TupleNumber((*hv_val), &(*hv_val));
  return;
}

void UpFaceCheck (HObject ho_Image, HTuple hv_MessageHandle, HTuple hv_WindowHandle, 
    HTuple *hv_Features, HTuple *hv_IsTrue)
{

  // Local iconic variables
  HObject  ho_Rect, ho_ImageReduced1, ho_Regions2;
  HObject  ho_ConnectedRegions2, ho_Selected1, ho_Selected2;
  HObject  ho_Circle, ho_RegionErosion, ho_RegionDifference;
  HObject  ho_ImageReduced4, ho_Region;

  // Local control variables
  HTuple  hv_Rectc1, hv_Rectc2, hv_Number1, hv_Area1;
  HTuple  hv_Row1, hv_Column1, hv_Ra, hv_Rb, hv_Phi1, hv_Number2;
  HTuple  hv_Area2, hv_Row2, hv_Column2, hv_Phi2, hv_Sequence;
  HTuple  hv_Feature, hv_Index, hv_Area, hv_Row, hv_Column;
  HTuple  hv_Deviation, hv_Newtuple;

  (*hv_Features) = HTuple();
  GetMessageObj(&ho_Rect, hv_MessageHandle, "Rect");
  DispObj(ho_Rect, hv_WindowHandle);
  ReduceDomain(ho_Image, ho_Rect, &ho_ImageReduced1);
  Threshold(ho_ImageReduced1, &ho_Regions2, 135, 255);
  Connection(ho_Regions2, &ho_ConnectedRegions2);
  GetMessageTuple(hv_MessageHandle, "Rectc1", &hv_Rectc1);
  GetMessageTuple(hv_MessageHandle, "Rectc2", &hv_Rectc2);
  SelectShape(ho_ConnectedRegions2, &ho_Selected1, (HTuple("height").Append("column")), 
      "and", HTuple(73.15).TupleConcat(hv_Rectc1), HTuple(1000).TupleConcat((hv_Rectc1+hv_Rectc2)/2));
  SelectShape(ho_ConnectedRegions2, &ho_Selected2, (HTuple("height").Append("column")), 
      "and", HTuple(73.15).TupleConcat((hv_Rectc1+hv_Rectc2)/2), HTuple(1000).TupleConcat(hv_Rectc2));
  Union1(ho_Selected1, &ho_Selected1);
  CountObj(ho_Selected1, &hv_Number1);
  (*hv_IsTrue) = 1;
  if (0 != (HTuple(hv_Number1>0).TupleAnd((*hv_IsTrue))))
  {
    AreaCenter(ho_Selected1, &hv_Area1, &hv_Row1, &hv_Column1);
    //
    EllipticAxis(ho_Selected1, &hv_Ra, &hv_Rb, &hv_Phi1);
    DispObj(ho_Selected1, hv_WindowHandle);
    (*hv_Features) = ((((((*hv_Features).TupleConcat(hv_Area1)).TupleConcat(hv_Row1)).TupleConcat(hv_Column1)).TupleConcat(hv_Ra)).TupleConcat(hv_Rb)).TupleConcat(hv_Phi1);
  }
  else
  {
    (*hv_Features) = (*hv_Features).TupleConcat((((((HTuple(0).Append(0)).Append(0)).Append(0)).Append(0)).Append(0)));
    (*hv_IsTrue) = 0;
  }
  Union1(ho_Selected2, &ho_Selected2);
  CountObj(ho_Selected2, &hv_Number2);
  if (0 != (HTuple(hv_Number2>0).TupleAnd((*hv_IsTrue))))
  {
    AreaCenter(ho_Selected2, &hv_Area2, &hv_Row2, &hv_Column2);
    EllipticAxis(ho_Selected1, &hv_Ra, &hv_Rb, &hv_Phi2);
    DispObj(ho_Selected2, hv_WindowHandle);
    (*hv_Features) = ((((((*hv_Features).TupleConcat(hv_Area2)).TupleConcat(hv_Row2)).TupleConcat(hv_Column2)).TupleConcat(hv_Ra)).TupleConcat(hv_Rb)).TupleConcat(hv_Phi2);
  }
  else
  {
    (*hv_Features) = (*hv_Features).TupleConcat((((((HTuple(0).Append(0)).Append(0)).Append(0)).Append(0)).Append(0)));
    (*hv_IsTrue) = 0;
  }
  if (0 != (*hv_IsTrue))
  {
    GetMessageObj(&ho_Circle, hv_MessageHandle, "Circle");
    DispObj(ho_Circle, hv_WindowHandle);
    ErosionCircle(ho_Circle, &ho_RegionErosion, 70);
    Difference(ho_RegionErosion, ho_Selected1, &ho_RegionDifference);
    Difference(ho_RegionDifference, ho_Selected2, &ho_RegionDifference);
    ReduceDomain(ho_Image, ho_RegionDifference, &ho_ImageReduced4);
    TupleGenSequence(0, 255, 10, &hv_Sequence);
    hv_Sequence = hv_Sequence.TupleConcat(255);
    hv_Feature = HTuple();
    {
    HTuple end_val44 = (hv_Sequence.TupleLength())-2;
    HTuple step_val44 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val44, step_val44); hv_Index += step_val44)
    {
      Threshold(ho_ImageReduced4, &ho_Region, HTuple(hv_Sequence[hv_Index]), HTuple(hv_Sequence[hv_Index+1]));
      AreaCenter(ho_Region, &hv_Area, &hv_Row, &hv_Column);
      hv_Feature = ((hv_Feature.TupleConcat(hv_Area)).TupleConcat(hv_Row)).TupleConcat(hv_Column);
    }
    }
    (*hv_Features) = (*hv_Features).TupleConcat(hv_Feature);
    TupleDeviation(hv_Index, &hv_Deviation);
    (*hv_Features) = (*hv_Features).TupleConcat(hv_Deviation);
  }
  else
  {
    TupleGenConst(78, 0, &hv_Newtuple);
    (*hv_Features) = ((*hv_Features).TupleConcat(hv_Newtuple)).TupleConcat(-100);
  }
  SetMessageTuple(hv_MessageHandle, "NumFeatures", (*hv_Features));
  //
  //
  return;
}

void create_object_drawID (HTuple hv_str, HTuple *hv_DrawID)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Substrings, hv_Substrings1, hv_Number1;

  //
  //['circle', 'circle_arc', 'ellipse', 'ellipse_arc', 'line', 'rectangle1', 'rectangle2']
  TupleSplit(hv_str, "(", &hv_Substrings);
  TupleSplit(hv_Substrings, ")", &hv_Substrings);
  TupleString(hv_Substrings, "#", &hv_Substrings);
  (*hv_DrawID) = HTuple();
  if (0 != ((hv_Substrings.TupleLength())==2))
  {
    TupleSplit(HTuple(hv_Substrings[1]), ",", &hv_Substrings1);
    TupleNumber(hv_Substrings1, &hv_Number1);
    if (0 != (HTuple(HTuple(HTuple(hv_Substrings[0])==HTuple("Circle")).TupleOr(HTuple(hv_Substrings[0])==HTuple("circle"))).TupleAnd((hv_Number1.TupleLength())>=3)))
    {
      CreateDrawingObjectCircle(HTuple(hv_Number1[0]), HTuple(hv_Number1[1]), HTuple(hv_Number1[2]), 
          &(*hv_DrawID));
    }
    else if (0 != (HTuple(HTuple(hv_Substrings[0])==HTuple("circle_arc")).TupleAnd((hv_Number1.TupleLength())>=5)))
    {
      CreateDrawingObjectCircleSector(HTuple(hv_Number1[0]), HTuple(hv_Number1[1]), 
          HTuple(hv_Number1[2]), HTuple(hv_Number1[3]), HTuple(hv_Number1[4]), &(*hv_DrawID));
    }
    else if (0 != (HTuple(HTuple(HTuple(hv_Substrings[0])==HTuple("Ellipse")).TupleOr(HTuple(hv_Substrings[0])==HTuple("ellipse"))).TupleAnd((hv_Number1.TupleLength())>=5)))
    {
      CreateDrawingObjectEllipse(HTuple(hv_Number1[0]), HTuple(hv_Number1[1]), HTuple(hv_Number1[2]), 
          HTuple(hv_Number1[3]), HTuple(hv_Number1[4]), &(*hv_DrawID));
    }
    else if (0 != (HTuple(HTuple(hv_Substrings[0])==HTuple("ellipse_arc")).TupleAnd((hv_Number1.TupleLength())>=7)))
    {
      CreateDrawingObjectEllipseSector(HTuple(hv_Number1[0]), HTuple(hv_Number1[1]), 
          HTuple(hv_Number1[2]), HTuple(hv_Number1[3]), HTuple(hv_Number1[4]), HTuple(hv_Number1[5]), 
          HTuple(hv_Number1[6]), &(*hv_DrawID));
    }
    else if (0 != (HTuple(HTuple(HTuple(hv_Substrings[0])==HTuple("Line")).TupleOr(HTuple(hv_Substrings[0])==HTuple("line"))).TupleAnd((hv_Number1.TupleLength())>=4)))
    {
      CreateDrawingObjectLine(HTuple(hv_Number1[0]), HTuple(hv_Number1[1]), HTuple(hv_Number1[2]), 
          HTuple(hv_Number1[3]), &(*hv_DrawID));
    }
    else if (0 != (HTuple(HTuple(HTuple(hv_Substrings[0])==HTuple("rectangle1")).TupleOr(HTuple(hv_Substrings[0])==HTuple("rectangle1"))).TupleAnd((hv_Number1.TupleLength())>=4)))
    {
      CreateDrawingObjectRectangle1(HTuple(hv_Number1[0]), HTuple(hv_Number1[1]), 
          HTuple(hv_Number1[2]), HTuple(hv_Number1[3]), &(*hv_DrawID));
    }
    else if (0 != (HTuple(HTuple(HTuple(hv_Substrings[0])==HTuple("rectangle2")).TupleOr(HTuple(hv_Substrings[0])==HTuple("rectangle2"))).TupleAnd((hv_Number1.TupleLength())>=5)))
    {
      CreateDrawingObjectRectangle2(HTuple(hv_Number1[0]), HTuple(hv_Number1[1]), 
          HTuple(hv_Number1[2]), HTuple(hv_Number1[3]), HTuple(hv_Number1[4]), &(*hv_DrawID));
    }
  }
  return;
}

void Set_DefaultVal_To_ini (HTuple hv_FileName, HTuple hv_Section, HTuple hv_KeyName, 
    HTuple hv_Defaultval)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_DefaultvalOut, hv_val, hv_FileExists;
  HTuple  hv_BaseName, hv_Extension, hv_Directory, hv_Substrings;
  HTuple  hv_Path;

  hv_DefaultvalOut = hv_Defaultval;
  hv_val = "";
  FileExists(hv_FileName, &hv_FileExists);
  if (0 != (hv_FileExists==0))
  {
    parse_filename(hv_FileName, &hv_BaseName, &hv_Extension, &hv_Directory);
    TupleSplit(hv_Directory, "/", &hv_Substrings);
    create_nodes(hv_Substrings, &hv_Path);
    ExConfigIniCreate(hv_FileName);
  }
  else
  {
    ExConfigIniReadStr(hv_FileName, hv_Section, hv_KeyName, "", &hv_val);
  }
  if (0 != (hv_val!=hv_DefaultvalOut))
  {
    TupleString(hv_DefaultvalOut, "#", &hv_DefaultvalOut);
    ExConfigIniWriteStr(hv_FileName, hv_Section, hv_KeyName, hv_DefaultvalOut);
  }
  //
  return;
}

void DreiFeatureExtract (HObject ho_Image, HTuple hv_WindowHandle, HTuple *hv_Feature)
{

  // Local iconic variables
  HObject  ho_ImageScaled, ho_Region1, ho_ConnectedRegions;
  HObject  ho_SelectedRegions, ho_RegionFillUp1, ho_RegionDilation1;
  HObject  ho_ImageReduced1, ho_RegionBorder;

  // Local control variables
  HTuple  hv_Number, hv_Circularity, hv_Mean, hv_Deviation;
  HTuple  hv_Area, hv_Row, hv_Column, hv_Convexity1, hv_ContLength;
  HTuple  hv_Compactness;

  //由于背面图像胶管部分对比度不够高，所以直接提取图像中心区域m
  ScaleImage(ho_Image, &ho_ImageScaled, 2, 0);
  Threshold(ho_ImageScaled, &ho_Region1, 150, 255);
  Connection(ho_Region1, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, "area", "and", 50000, 9999999);
  CountObj(ho_SelectedRegions, &hv_Number);
  if (0 != (hv_Number==0))
  {
    //
    (*hv_Feature).Clear();
    (*hv_Feature)[0] = 0;
    (*hv_Feature)[1] = 0;
    (*hv_Feature)[2] = 0;
    (*hv_Feature)[3] = 0;
    (*hv_Feature)[4] = 0;
    (*hv_Feature)[5] = 0;
    (*hv_Feature)[6] = 0;
  }
  else
  {
    Circularity(ho_SelectedRegions, &hv_Circularity);
    //Circularity是提取的第1个特征值
    //
    FillUp(ho_SelectedRegions, &ho_RegionFillUp1);
    DilationCircle(ho_RegionFillUp1, &ho_RegionDilation1, 5);
    ReduceDomain(ho_Image, ho_RegionDilation1, &ho_ImageReduced1);
    //此处所得到的是中心亮片区域n
    //
    //下面提取特征
    Intensity(ho_ImageReduced1, ho_Image, &hv_Mean, &hv_Deviation);
    //Mean是第2个提取的特征值
    //Dweviation是第3个提取的特征值
    AreaCenter(ho_ImageReduced1, &hv_Area, &hv_Row, &hv_Column);
    //Area是第4个提取的特征值
    Boundary(ho_RegionDilation1, &ho_RegionBorder, "inner");
    Convexity(ho_ImageReduced1, &hv_Convexity1);
    //Convexity1是第5个提取的特征值
    Contlength(ho_RegionBorder, &hv_ContLength);
    //contlength是第6个提取的特征值
    Compactness(ho_ImageReduced1, &hv_Compactness);
    //Compactness是第7个提取的特征值
    //
    (*hv_Feature).Clear();
    (*hv_Feature).Append(hv_Circularity);
    (*hv_Feature).Append(hv_Mean);
    (*hv_Feature).Append(hv_Deviation);
    (*hv_Feature).Append(hv_Area);
    (*hv_Feature).Append(hv_Convexity1);
    (*hv_Feature).Append(hv_ContLength);
    (*hv_Feature).Append(hv_Compactness);
  }
  //
  //
  return;
}

void PreprocessImage (HObject ho_Image, HObject *ho_PreprocessImage, HTuple hv_MessageHandle)
{

  // Local iconic variables
  HObject  ho_ImageMirror;

  // Local control variables
  HTuple  hv_PreprocessType, hv_Exception;

  try
  {
    //
    //图像预处理方式
    GetMessageTuple(hv_MessageHandle, "PreprocessType", &hv_PreprocessType);
    if (0 != (hv_PreprocessType==1))
    {
      MirrorImage(ho_Image, &(*ho_PreprocessImage), "row");
    }
    else if (0 != (hv_PreprocessType==2))
    {
      MirrorImage(ho_Image, &(*ho_PreprocessImage), "column");
    }
    else if (0 != (hv_PreprocessType==3))
    {
      RotateImage(ho_Image, &(*ho_PreprocessImage), 90, "constant");
    }
    else if (0 != (hv_PreprocessType==4))
    {
      RotateImage(ho_Image, &(*ho_PreprocessImage), -90, "constant");
    }
    else if (0 != (hv_PreprocessType==5))
    {
      MirrorImage(ho_Image, &ho_ImageMirror, "row");
      RotateImage(ho_ImageMirror, &(*ho_PreprocessImage), -90, "constant");
    }
    else
    {
      CopyImage(ho_Image, &(*ho_PreprocessImage));
    }
  }
  // catch (Exception) 
  catch (HalconCpp::HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
  }
  return;
}

void load_config_set_message_Number (HTuple hv_MessageHandle, HTuple hv_ParamSettingsFile, 
    HTuple hv_section, HTuple hv_Inikey, HTuple hv_MessageKey, HTuple hv_Defaultval, 
    HTuple *hv_val)
{

  // Local control variables
  HTuple  hv_IsExit;

  load_config_number(hv_ParamSettingsFile, hv_section, hv_Inikey, hv_Defaultval, 
      &(*hv_val));
  MessageExit(hv_MessageHandle, hv_MessageKey, (*hv_val), &hv_IsExit);
  //
  return;
}

void gen_region_by_str (HObject *ho_Region, HTuple hv_str, HTuple *hv_Type)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_Substrings, hv_Substrings1, hv_Number1;

  GenEmptyRegion(&(*ho_Region));
  (*hv_Type) = "";
  TupleSplit(hv_str, "(", &hv_Substrings);
  TupleSplit(hv_Substrings, ")", &hv_Substrings);
  TupleString(hv_Substrings, "#", &hv_Substrings);
  if (0 != ((hv_Substrings.TupleLength())==2))
  {
    TupleSplit(HTuple(hv_Substrings[1]), ",", &hv_Substrings1);
    TupleNumber(hv_Substrings1, &hv_Number1);
    if (0 != (HTuple(HTuple(HTuple(hv_Substrings[0])==HTuple("Circle")).TupleOr(HTuple(hv_Substrings[0])==HTuple("circle"))).TupleAnd((hv_Number1.TupleLength())>=3)))
    {
      GenCircle(&(*ho_Region), HTuple(hv_Number1[0]), HTuple(hv_Number1[1]), HTuple(hv_Number1[2]));
      (*hv_Type) = ((const HTuple&)hv_Substrings)[0];
    }
    else if (0 != (HTuple(HTuple(hv_Substrings[0])==HTuple("circle_arc")).TupleAnd((hv_Number1.TupleLength())>=5)))
    {
      GenCircleSector(&(*ho_Region), HTuple(hv_Number1[0]), HTuple(hv_Number1[1]), 
          HTuple(hv_Number1[2]), HTuple(hv_Number1[3]), HTuple(hv_Number1[4]));
      (*hv_Type) = ((const HTuple&)hv_Substrings)[0];
    }
    else if (0 != (HTuple(HTuple(HTuple(hv_Substrings[0])==HTuple("Ellipse")).TupleOr(HTuple(hv_Substrings[0])==HTuple("ellipse"))).TupleAnd((hv_Number1.TupleLength())>=5)))
    {
      GenEllipse(&(*ho_Region), HTuple(hv_Number1[0]), HTuple(hv_Number1[1]), HTuple(hv_Number1[2]), 
          HTuple(hv_Number1[3]), HTuple(hv_Number1[4]));
      (*hv_Type) = ((const HTuple&)hv_Substrings)[0];
    }
    else if (0 != (HTuple(HTuple(hv_Substrings[0])==HTuple("ellipse_arc")).TupleAnd((hv_Number1.TupleLength())>=7)))
    {
      GenEllipseSector(&(*ho_Region), HTuple(hv_Number1[0]), HTuple(hv_Number1[1]), 
          HTuple(hv_Number1[2]), HTuple(hv_Number1[3]), HTuple(hv_Number1[4]), HTuple(hv_Number1[5]), 
          HTuple(hv_Number1[6]));
      (*hv_Type) = ((const HTuple&)hv_Substrings)[0];
    }
    else if (0 != (HTuple(HTuple(HTuple(hv_Substrings[0])==HTuple("Line")).TupleOr(HTuple(hv_Substrings[0])==HTuple("line"))).TupleAnd((hv_Number1.TupleLength())>=4)))
    {
      GenRegionLine(&(*ho_Region), HTuple(hv_Number1[0]), HTuple(hv_Number1[1]), 
          HTuple(hv_Number1[2]), HTuple(hv_Number1[3]));
      (*hv_Type) = ((const HTuple&)hv_Substrings)[0];
    }
    else if (0 != (HTuple(HTuple(HTuple(hv_Substrings[0])==HTuple("rectangle1")).TupleOr(HTuple(hv_Substrings[0])==HTuple("rectangle1"))).TupleAnd((hv_Number1.TupleLength())>=4)))
    {
      GenRectangle1(&(*ho_Region), HTuple(hv_Number1[0]), HTuple(hv_Number1[1]), 
          HTuple(hv_Number1[2]), HTuple(hv_Number1[3]));
      (*hv_Type) = ((const HTuple&)hv_Substrings)[0];
    }
    else if (0 != (HTuple(HTuple(HTuple(hv_Substrings[0])==HTuple("rectangle2")).TupleOr(HTuple(hv_Substrings[0])==HTuple("rectangle2"))).TupleAnd((hv_Number1.TupleLength())>=5)))
    {
      GenRectangle2(&(*ho_Region), HTuple(hv_Number1[0]), HTuple(hv_Number1[1]), 
          HTuple(hv_Number1[2]), HTuple(hv_Number1[3]), HTuple(hv_Number1[4]));
      (*hv_Type) = ((const HTuple&)hv_Substrings)[0];
    }
  }
  return;
}

void Check_DownSur (HObject ho_Image, HTuple hv_ShowHide, HTuple hv_WindowHandle, 
    HTuple hv_MessageHandle, HTuple *hv_ResultInfo, HTuple *hv_WindowInfo, HTupleVector/*{eTupleVector,Dim=2}*/ *hvec_FeatureVals)
{

  // Local iconic variables
  HObject  ho_EmptyRegion, ho_ImageReduced1, ho_Region;
  HObject  ho_ImageResult;

  // Local control variables
  HTuple  hv_Width, hv_Height, hv_thresholdval;
  HTuple  hv_erosion_dilation, hv_ProductCentre, hv_EmptyRegionVals;
  HTuple  hv_Number, hv_Area, hv_Row6, hv_Column1, hv_PyResultVal;
  HTuple  hv_PyResultInfo, hv_PyWindowInfo;
  HTupleVector  hvec_PyFeatureVals(2);

  (*hv_ResultInfo) = "OK";
  (*hv_WindowInfo) = "";
  (*hvec_FeatureVals) = HTupleVector(2);
  GetImageSize(ho_Image, &hv_Width, &hv_Height);
  GetMessageTuple(hv_MessageHandle, "thresholdval", &hv_thresholdval);
  GetMessageTuple(hv_MessageHandle, "erosion_dilation", &hv_erosion_dilation);


  //'产品中心'
  GetMessageTuple(hv_MessageHandle, "ProductCentre", &hv_ProductCentre);
  GetMessageObj(&ho_EmptyRegion, hv_MessageHandle, "EmptyRegion");
  //判断是否空料的区域
  GetMessageObj(&ho_EmptyRegion, hv_MessageHandle, "EmptyRegion");
  GetMessageTuple(hv_MessageHandle, "EmptyRegionVals", &hv_EmptyRegionVals);
  ReduceDomain(ho_Image, ho_EmptyRegion, &ho_ImageReduced1);
  Threshold(ho_ImageReduced1, &ho_Region, 0, 230);
  CountObj(ho_Region, &hv_Number);
  if (0 != (hv_Number>=1))
  {
    AreaCenter(ho_Region, &hv_Area, &hv_Row6, &hv_Column1);
    if (0 != (hv_Area<50))
    {
      (*hv_ResultInfo) = "空料";
      return;
    }
  }


  Py_Memory_Check(ho_Image, &ho_ImageResult, hv_MessageHandle, hv_WindowHandle, hv_ShowHide, 
      hv_Width, hv_Height, HTuple(), &hv_PyResultVal);
  GetPyFeature(ho_ImageResult, hv_MessageHandle, hv_ShowHide, hv_WindowHandle, hv_PyResultVal, 
      &hv_PyResultInfo, &hv_PyWindowInfo, &hvec_PyFeatureVals);
  (*hv_ResultInfo) = hv_PyResultInfo;


  (*hv_WindowInfo) = hv_PyWindowInfo;
  (*hvec_FeatureVals) = hvec_PyFeatureVals;


  return;
}

void Py_Memory_Check (HObject ho_Image, HObject *ho_ImageResult, HTuple hv_MessageHandle, 
    HTuple hv_WindowHandle, HTuple hv_ShowHide, HTuple hv_Width, HTuple hv_Height, 
    HTuple hv_ImageInfos, HTuple *hv_ResultVal)
{

  // Local iconic variables
  HObject  ho_ErrorRegion;

  // Local control variables
  HTuple  hv_UsePythonCheck, hv_FileName_Image_handle;
  HTuple  hv_FileName_ImageInfo_handle, hv_FileName_ImageResultN_handle;
  HTuple  hv_ImageResultN, hv_Resulti, hv_FileName_ImageTrigger_handle;
  HTuple  hv_ImageTrigger, hv_AICheckTime, hv_Secondstart;
  HTuple  hv_FileName_ResultInfo_handle, hv_ImageResultInfo;
  HTuple  hv_FileName_ImageResult_handle, hv_Secondend;


  GenEmptyObj(&ho_ErrorRegion);
  //是否使用python共享内存方式检测
  GetMessageTuple(hv_MessageHandle, "UsePythonCheck", &hv_UsePythonCheck);
  (*hv_ResultVal) = -10;
  GenImageConst(&(*ho_ImageResult), "byte", hv_Width, hv_Height);
  if (0 != (hv_UsePythonCheck!=0))
  {
    //先将图像写进内存
    GetMessageTuple(hv_MessageHandle, "FileName_Image_handle", &hv_FileName_Image_handle);
    ExMapviewoffilewriteimage(ho_Image, hv_FileName_Image_handle, 0);
    //写图像信息 宽，高，等其它信息
    GetMessageTuple(hv_MessageHandle, "FileName_ImageInfo_handle", &hv_FileName_ImageInfo_handle);
    ExMapviewoffilewrite(hv_FileName_ImageInfo_handle, 2, (hv_Width.TupleConcat(hv_Height)).TupleConcat(hv_ImageInfos), 
        0);
    //获取上一次的结果计数
    GetMessageTuple(hv_MessageHandle, "FileName_ImageResultN_handle", &hv_FileName_ImageResultN_handle);
    ExMapviewoffileread(hv_FileName_ImageResultN_handle, 2, 0, 1, &hv_ImageResultN);
    hv_Resulti = hv_ImageResultN;
    //
    //触发python检测计数
    GetMessageTuple(hv_MessageHandle, "FileName_ImageTrigger_handle", &hv_FileName_ImageTrigger_handle);
    ExMapviewoffileread(hv_FileName_ImageTrigger_handle, 2, 0, 1, &hv_ImageTrigger);
    if (0 != (HTuple(hv_ImageTrigger>8).TupleOr(hv_ImageTrigger<0)))
    {
      hv_ImageTrigger = 0;
    }
    else
    {
      hv_ImageTrigger += 1;
    }
    ExMapviewoffilewrite(hv_FileName_ImageTrigger_handle, 2, hv_ImageTrigger, 0);
    //获取python检测结果
    GetMessageTuple(hv_MessageHandle, "AICheckTime", &hv_AICheckTime);
    hv_AICheckTime = hv_AICheckTime*0.001;
    CountSeconds(&hv_Secondstart);

    while (0 != 1)
    {
      ExMapviewoffileread(hv_FileName_ImageResultN_handle, 2, 0, 1, &hv_ImageResultN);
      //如果与上一次结果计数不一致  表示已经完成检测
      if (0 != (hv_ImageResultN!=hv_Resulti))
      {
        GetMessageTuple(hv_MessageHandle, "FileName_ResultInfo_handle", &hv_FileName_ResultInfo_handle);
        ExMapviewoffileread(hv_FileName_ResultInfo_handle, 2, 0, 2, &hv_ImageResultInfo);
        GetMessageTuple(hv_MessageHandle, "FileName_ImageResult_handle", &hv_FileName_ImageResult_handle);
        ExMapviewoffilereadimage(&(*ho_ImageResult), hv_FileName_ImageResult_handle, 
            0, 0, HTuple(hv_ImageResultInfo[1]), HTuple(hv_ImageResultInfo[0]));
        (*hv_ResultVal) = 1;
        return;
      }
      CountSeconds(&hv_Secondend);
      if (0 != ((hv_Secondend-hv_Secondstart)>hv_AICheckTime))
      {
        (*hv_ResultVal) = -100;
        return;
      }

    }
  }




  return;
}

void Check_Floor (HObject ho_Image, HTuple hv_ShowHide, HTuple hv_WindowHandle, HTuple hv_MessageHandle, 
    HTuple *hv_ResultInfo, HTuple *hv_WindowInfo, HTupleVector/*{eTupleVector,Dim=2}*/ *hvec_FeatureVals)
{

  // Local iconic variables
  HObject  ho_ImageResult;

  // Local control variables
  HTuple  hv_Width, hv_Height, hv_PyResultVal, hv_PyResultInfo;
  HTuple  hv_PyWindowInfo;
  HTupleVector  hvec_PyFeatureVals(2);




  //
  //Features_retResults_nReginType检测区域类型
  //Features_retResults_strReginType检测类型字符串，返回值为“左面”或“右面”
  //Features_retResults_rectval错误区域外界矩形坐标
  //Features_retResults_ErrorType....................................错误类型
  //Features_retResults_strErrortype ....................................//错误类型字符串，返回值为“暗斑”，“干料”等缺陷中文名称
  //Features_retResults_ErrorContrast//缺陷对比度
  //Features_retResults_ErrorArea// 错误面积
  //Features_retResults_Diameter....................................错误面积
  //Features_retResults_Descript字符串描述
  //Features_retResults_nLevel....................................错误程度
  //Features_retResults_x....................................缺陷水平方向坐标
  //Features_retResults_y....................................缺陷垂直方向坐标
  //Features_retResults_fFeature
  //Features_retResults_ifTag....................................是否打标
  //Features_retResults_TagLength....................................打标持续行数
  //
  //Features_properDynThresh....................................
  //Features_regionWidthPix....................................
  //Features_regionHeightPix....................................  //缺陷本身的宽高
  //Features_errAreaPix;   //像素面积
  //Features_sImgLeft, //生成的小图区域
  //Features_sImgRight, //生成的小图区域
  //Features_sImgTop, //生成的小图区域
  //Features_sImgBotton;  //生成的小图区域
  //Features_ifInterWithEdge;   //是否跟边缘区域有交集
  //Features_ifNearEdge; //是否靠近边缘
  //Features_errHeight ....................................
  //Features_errWidth; ....................................分割的大块边缘区域宽高
  //Features_sImageHeight
  //Features_sImageWidth;   //小图区域宽高
  //Features_ifCrowded....................................是否密度过大


  (*hv_ResultInfo) = "";
  (*hv_WindowInfo) = HTuple();
  (*hvec_FeatureVals) = HTupleVector(2);
  GetImageSize(ho_Image, &hv_Width, &hv_Height);

  Py_Memory_Check(ho_Image, &ho_ImageResult, hv_MessageHandle, hv_WindowHandle, hv_ShowHide, 
      hv_Width, hv_Height, HTuple(), &hv_PyResultVal);
  GetPyFeature(ho_ImageResult, hv_MessageHandle, hv_ShowHide, hv_WindowHandle, hv_PyResultVal, 
      &hv_PyResultInfo, &hv_PyWindowInfo, &hvec_PyFeatureVals);

  (*hv_ResultInfo) = hv_PyResultInfo;

  (*hvec_FeatureVals) = hvec_PyFeatureVals;
  (*hv_WindowInfo) = hv_PyWindowInfo;
  //
  //

  return;
}

void GetPyFeature (HObject ho_ImageResult, HTuple hv_MessageHandle, HTuple hv_ShowHide, 
    HTuple hv_WindowHandle, HTuple hv_PyResultVal, HTuple *hv_ResultInfo, HTuple *hv_WindowInfo, 
    HTupleVector/*{eTupleVector,Dim=2}*/ *hvec_FeatureVals)
{

  // Local iconic variables
  HObject  ho_GrayRegion;

  // Local control variables
  HTuple  hv_PyCheckTimeOutResult, hv_PyDefaultResult;
  HTuple  hv_PyFileIndex, hv_PyImageGaryTypeName, hv_PyImageGaryPriority;
  HTuple  hv_MinNum, hv_GrayIndex, hv_GrayArea, hv_GrayRow;
  HTuple  hv_GrayColumn, hv_Row11, hv_Column11, hv_Row21;
  HTuple  hv_Column21, hv_Diameter, hv_Row1, hv_Column1, hv_Row2;
  HTuple  hv_Column2, hv_Py_ResultUse;
  HTupleVector  hvec_FeatureVal(1);

  hvec_FeatureVal = HTupleVector(1);
  (*hvec_FeatureVals) = HTupleVector(2);
  (*hv_WindowInfo) = "";
  GetMessageTuple(hv_MessageHandle, "PyCheckTimeOutResult", &hv_PyCheckTimeOutResult);
  GetMessageTuple(hv_MessageHandle, "PyCheckErrorResult", &hv_PyCheckTimeOutResult);
  GetMessageTuple(hv_MessageHandle, "PyDefaultResult", &hv_PyDefaultResult);
  GetMessageTuple(hv_MessageHandle, "PyFileIndex", &hv_PyFileIndex);
  (*hv_WindowInfo) = "Py内存区号:"+hv_PyFileIndex;
  (*hv_ResultInfo) = "";
  if (0 != (hv_PyResultVal==-10))
  {
    //没有检测
    (*hv_ResultInfo) = hv_PyDefaultResult;
    (*hv_WindowInfo) = "AI_没有检测";
  }
  else if (0 != (hv_PyResultVal==-100))
  {
    //检测超时
    (*hv_ResultInfo) = hv_PyCheckTimeOutResult;
    (*hv_WindowInfo) = "AI_检测超时";
  }
  else if (0 != (hv_PyResultVal==1))
  {
    GetMessageTuple(hv_MessageHandle, "PyImageDefaultTypeName", &(*hv_ResultInfo));
    GetMessageTuple(hv_MessageHandle, "PyImageGaryTypeName", &hv_PyImageGaryTypeName);
    GetMessageTuple(hv_MessageHandle, "PyImageGaryPriority", &hv_PyImageGaryPriority);
    TupleMin(HTuple(hv_PyImageGaryTypeName.TupleLength()).TupleConcat(hv_PyImageGaryPriority.TupleLength()), 
        &hv_MinNum);
    {
    HTuple end_val22 = hv_MinNum-1;
    HTuple step_val22 = 1;
    for (hv_GrayIndex=0; hv_GrayIndex.Continue(end_val22, step_val22); hv_GrayIndex += step_val22)
    {
      Threshold(ho_ImageResult, &ho_GrayRegion, HTuple(hv_PyImageGaryPriority[hv_GrayIndex]), 
          HTuple(hv_PyImageGaryPriority[hv_GrayIndex]));
      AreaCenter(ho_GrayRegion, &hv_GrayArea, &hv_GrayRow, &hv_GrayColumn);
      if (0 != (hv_GrayArea>0))
      {
        if (0 != hv_ShowHide)
        {
          DispObj(ho_GrayRegion, hv_WindowHandle);
        }
        hvec_FeatureVal.Insert(hvec_FeatureVal.Length(),HTupleVector(HTuple(HTuple("Features_retResults_nRegionType").TupleConcat(HTuple(hv_PyImageGaryPriority[hv_GrayIndex])))));
        hvec_FeatureVal.Insert(hvec_FeatureVal.Length(),HTupleVector(HTuple(HTuple("Features_retResults_ErrorArea").TupleConcat(hv_GrayArea.TupleInt()))));
        hvec_FeatureVal.Insert(hvec_FeatureVal.Length(),HTupleVector(HTuple(HTuple("Features_retResults_x").TupleConcat(hv_GrayColumn.TupleInt()))));
        hvec_FeatureVal.Insert(hvec_FeatureVal.Length(),HTupleVector(HTuple(HTuple("Features_retResults_y").TupleConcat(hv_GrayRow.TupleInt()))));
        DiameterRegion(ho_GrayRegion, &hv_Row11, &hv_Column11, &hv_Row21, &hv_Column21, 
            &hv_Diameter);
        hvec_FeatureVal.Insert(hvec_FeatureVal.Length(),HTupleVector(HTuple(HTuple("Features_retResults_Diameter").TupleConcat(hv_Diameter.TupleInt()))));
        SmallestRectangle1(ho_GrayRegion, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
        hvec_FeatureVal.Insert(hvec_FeatureVal.Length(),HTupleVector(HTuple(HTuple("Features_retResults_rectvals").TupleConcat((((hv_Column1.TupleInt()).TupleConcat(hv_Row1.TupleInt())).TupleConcat(hv_Column2.TupleInt())).TupleConcat(hv_Row2.TupleInt())))));
        hvec_FeatureVal.Insert(hvec_FeatureVal.Length(),HTupleVector((HTuple("Features_retResults_ifTag").Append(0))));
        hvec_FeatureVal.Insert(hvec_FeatureVal.Length(),HTupleVector((HTuple("Features_retResults_Alarm").Append(0))));
        (*hvec_FeatureVals).Insert((*hvec_FeatureVals).Length(),hvec_FeatureVal);
        (*hv_ResultInfo) = ((const HTuple&)hv_PyImageGaryTypeName)[hv_GrayIndex];

        if (0 != hv_ShowHide)
        {
          SetColor(hv_WindowHandle, "red");
          DispObj(ho_GrayRegion, hv_WindowHandle);
          SetColor(hv_WindowHandle, "green");
        }
        break;
      }
    }
    }
  }

  GetMessageTuple(hv_MessageHandle, "Py_ResultUse", &hv_Py_ResultUse);
  if (0 != (hv_Py_ResultUse!=1))
  {
    (*hv_ResultInfo) = hv_PyDefaultResult;
    (*hv_WindowInfo) += HTuple("\r\nAI_Result禁用");
  }
  if (0 != ((*hv_ResultInfo)==HTuple("")))
  {
    (*hv_ResultInfo) = hv_PyDefaultResult;
  }
  (*hv_WindowInfo) = ((*hv_WindowInfo)+"\r\nAI_检测:")+(*hv_ResultInfo);


  return;
}

void Init_TopSurfaceDetection (HTuple hv_CurrentScheme, HTuple hv_lsCheckParam, HTuple hv_MessageHandle)
{

  // Local iconic variables
  HObject  ho_EmptyRegion, ho_CheckRegion;

  // Local control variables
  HTuple  hv_DiameterVal, hv_Diameter_offset, hv_DiameterMinMax;
  HTuple  hv_GuidepinVal, hv_Guidepin_offset, hv_GuidepinMinMax;
  HTuple  hv_ProductCentre, hv_resolutionratio, hv_EmptyRegionVals;
  HTuple  hv_wh, hv_CheckRegionVals, hv_val;

  load_config_number(hv_CurrentScheme, HTuple(hv_lsCheckParam[0]), "直径", 18, &hv_DiameterVal);
  load_config_number(hv_CurrentScheme, HTuple(hv_lsCheckParam[0]), "直径容差", 0.5, 
      &hv_Diameter_offset);
  hv_DiameterMinMax.Clear();
  hv_DiameterMinMax.Append(hv_DiameterVal-hv_Diameter_offset);
  hv_DiameterMinMax.Append(hv_DiameterVal+hv_Diameter_offset);
  SetMessageTuple(hv_MessageHandle, "DiameterMinMax", hv_DiameterMinMax);

  load_config_number(hv_CurrentScheme, HTuple(hv_lsCheckParam[0]), "导针间距", 6, 
      &hv_GuidepinVal);
  load_config_number(hv_CurrentScheme, HTuple(hv_lsCheckParam[0]), "导针间距容差", 
      0.5, &hv_Guidepin_offset);
  hv_GuidepinMinMax.Clear();
  hv_GuidepinMinMax.Append(hv_GuidepinVal-hv_Guidepin_offset);
  hv_GuidepinMinMax.Append(hv_GuidepinVal+hv_Guidepin_offset);


  load_config_split_numeber(hv_CurrentScheme, HTuple(hv_lsCheckParam[0]), "产品中心", 
      "1000,1369", ",", &hv_ProductCentre);
  SetMessageTuple(hv_MessageHandle, "ProductCentre", hv_ProductCentre);
  GetMessageTuple(hv_MessageHandle, "resolutionratio", &hv_resolutionratio);
  //生成判断是否空料的区域
  hv_EmptyRegionVals.Clear();
  hv_EmptyRegionVals.Append(HTuple(hv_ProductCentre[0])-(((1.0*hv_DiameterVal)/hv_resolutionratio)/2));
  hv_EmptyRegionVals.Append(HTuple(hv_ProductCentre[1]));
  hv_EmptyRegionVals.Append(HTuple(hv_ProductCentre[0])+(((1.0*hv_DiameterVal)/hv_resolutionratio)/2));
  hv_EmptyRegionVals.Append(HTuple(hv_ProductCentre[1]));
  GenRectangle1(&ho_EmptyRegion, HTuple(hv_EmptyRegionVals[0]), HTuple(hv_EmptyRegionVals[1]), 
      HTuple(hv_EmptyRegionVals[2]), HTuple(hv_EmptyRegionVals[3]));
  SetMessageObj(ho_EmptyRegion, hv_MessageHandle, "EmptyRegion");
  SetMessageTuple(hv_MessageHandle, "EmptyRegionVals", hv_EmptyRegionVals);

  //生成产品预处理检测区域
  hv_wh = (((1.0*hv_DiameterVal)/hv_resolutionratio)/2)+100;
  hv_CheckRegionVals.Clear();
  hv_CheckRegionVals.Append(HTuple(hv_ProductCentre[0])-hv_wh);
  hv_CheckRegionVals.Append(HTuple(hv_ProductCentre[1])-hv_wh);
  hv_CheckRegionVals.Append(HTuple(hv_ProductCentre[0])+hv_wh);
  hv_CheckRegionVals.Append(HTuple(hv_ProductCentre[1])+hv_wh);
  GenRectangle1(&ho_CheckRegion, HTuple(hv_CheckRegionVals[0]), HTuple(hv_CheckRegionVals[1]), 
      HTuple(hv_CheckRegionVals[2]), HTuple(hv_CheckRegionVals[3]));
  SetMessageObj(ho_CheckRegion, hv_MessageHandle, "CheckRegion");
  SetMessageTuple(hv_MessageHandle, "CheckRegionVals", hv_CheckRegionVals);


  SetMessageTuple(hv_MessageHandle, "GuidepinMinMax", hv_GuidepinMinMax);


  load_config_number(hv_CurrentScheme, HTuple(hv_lsCheckParam[0]), "thresholdval", 
      140, &hv_val);
  SetMessageTuple(hv_MessageHandle, "thresholdval", hv_val);
  load_config_number(hv_CurrentScheme, HTuple(hv_lsCheckParam[0]), "erosion_dilation", 
      15, &hv_val);
  SetMessageTuple(hv_MessageHandle, "erosion_dilation", hv_val);

  return;
}

void Init_Python_Memory (HTuple hv_TestPlanIni, HTuple hv_CheckParam, HTuple hv_MessageHandle)
{

  // Local control variables
  HTuple  hv_PyCheckTimeOutResult, hv_PyDefaultResult;
  HTuple  hv_PyFileIndex, hv_Py_ResultUse, hv_UsePythonCheck;
  HTuple  hv_FileName_ImageInfo, hv_FileName_ImageInfo_handle;
  HTuple  hv_FileName_ImageResultN, hv_FileName_ImageResultN_handle;
  HTuple  hv_FileName_ImageResult, hv_FileName_ImageResult_handle;
  HTuple  hv_FileName_ImageTrigger, hv_FileName_ImageTrigger_handle;
  HTuple  hv_FileName_Image, hv_FileName_Image_handle, hv_FileName_ResultInfo;
  HTuple  hv_FileName_ResultInfo_handle, hv_AICheckTime, hv_PyImageDefaultTypeName;
  HTuple  hv_PyImageGaryTypeName, hv_PyImageGaryPriority;

  //是否使用python共享内存方式检测
  load_config_set_message_Str(hv_MessageHandle, hv_TestPlanIni, hv_CheckParam, "Py检测超时Result", 
      "PyCheckTimeOutResult", "NG", &hv_PyCheckTimeOutResult);
  load_config_set_message_Str(hv_MessageHandle, hv_TestPlanIni, hv_CheckParam, "Py检测报错Result", 
      "PyCheckErrorResult", "NG", &hv_PyCheckTimeOutResult);
  load_config_set_message_Str(hv_MessageHandle, hv_TestPlanIni, hv_CheckParam, "Py默认Result", 
      "PyDefaultResult", "OK", &hv_PyDefaultResult);
  load_config_set_message_Number(hv_MessageHandle, hv_TestPlanIni, hv_CheckParam, 
      "Py内存区号", "PyFileIndex", 1, &hv_PyFileIndex);

  load_config_set_message_Number(hv_MessageHandle, hv_TestPlanIni, hv_CheckParam, 
      "Py_结果开启", "Py_ResultUse", 1, &hv_Py_ResultUse);

  load_config_set_message_Number(hv_MessageHandle, hv_TestPlanIni, hv_CheckParam, 
      "Py检测开启", "UsePythonCheck", 1, &hv_UsePythonCheck);
  if (0 != (hv_UsePythonCheck!=1))
  {
    return;
  }


  //图像信息 [宽，高...]
  load_config(hv_TestPlanIni, hv_CheckParam, "FileName_ImageInfo", 7*4, &hv_FileName_ImageInfo);
  IniMapFile("ImageInfo"+hv_PyFileIndex, hv_FileName_ImageInfo, &hv_FileName_ImageInfo_handle);
  SetMessageTuple(hv_MessageHandle, "FileName_ImageInfo_handle", hv_FileName_ImageInfo_handle);
  //
  //上一次的结果计数
  load_config(hv_TestPlanIni, hv_CheckParam, "FileName_ImageResultN", 1*4, &hv_FileName_ImageResultN);
  IniMapFile("SimvisionImageResultN"+hv_PyFileIndex, hv_FileName_ImageResultN, &hv_FileName_ImageResultN_handle);
  SetMessageTuple(hv_MessageHandle, "FileName_ImageResultN_handle", hv_FileName_ImageResultN_handle);
  //
  //* 返回结果(以单通道图像byte形式返回,灰度为0的区域表示合格区,>0的灰度值为缺陷,灰度的值表示缺陷类型)
  load_config(hv_TestPlanIni, hv_CheckParam, "FileName_ImageResult(w*h)", 4096*4096, 
      &hv_FileName_ImageResult);
  IniMapFile("SimvisionImageResult"+hv_PyFileIndex, hv_FileName_ImageResult, &hv_FileName_ImageResult_handle);
  SetMessageTuple(hv_MessageHandle, "FileName_ImageResult_handle", hv_FileName_ImageResult_handle);

  //触发python检测计数区
  load_config(hv_TestPlanIni, hv_CheckParam, "FileName_ImageTrigger", 1*4, &hv_FileName_ImageTrigger);
  IniMapFile("SimvisionImageTrigger"+hv_PyFileIndex, hv_FileName_ImageTrigger, &hv_FileName_ImageTrigger_handle);
  SetMessageTuple(hv_MessageHandle, "FileName_ImageTrigger_handle", hv_FileName_ImageTrigger_handle);
  //图像存储区(发送给python的图像)
  load_config(hv_TestPlanIni, hv_CheckParam, "FileName_Image(w*h)", 4096*4096, &hv_FileName_Image);
  IniMapFile("SimvisionImage"+hv_PyFileIndex, hv_FileName_Image, &hv_FileName_Image_handle);
  SetMessageTuple(hv_MessageHandle, "FileName_Image_handle", hv_FileName_Image_handle);

  //python返回图像信息存储[height,width]
  load_config(hv_TestPlanIni, hv_CheckParam, "FileName_ResultInfo(w*h)", 4096*4096, 
      &hv_FileName_ResultInfo);
  IniMapFile("ResultInfo"+hv_PyFileIndex, hv_FileName_ResultInfo, &hv_FileName_ResultInfo_handle);
  SetMessageTuple(hv_MessageHandle, "FileName_ResultInfo_handle", hv_FileName_ResultInfo_handle);

  //
  //检测超时时间
  load_config_number(hv_TestPlanIni, hv_CheckParam, "AI检测超时(ms)", 500, &hv_AICheckTime);
  SetMessageTuple(hv_MessageHandle, "AICheckTime", hv_AICheckTime);


  load_config_set_message_Str(hv_MessageHandle, hv_TestPlanIni, hv_CheckParam, "Py图像默认类型名称", 
      "PyImageDefaultTypeName", "OK", &hv_PyImageDefaultTypeName);
  load_config_set_message_Str(hv_MessageHandle, hv_TestPlanIni, hv_CheckParam, "Py图像灰度类型名称", 
      "PyImageGaryTypeName", "NG", &hv_PyImageGaryTypeName);
  load_config_set_message_Str(hv_MessageHandle, hv_TestPlanIni, hv_CheckParam, "Py灰度优先级", 
      "PyImageGaryPriority", "1", &hv_PyImageGaryPriority);
  TupleSplit(hv_PyImageGaryPriority, "|", &hv_PyImageGaryPriority);
  TupleNumber(hv_PyImageGaryPriority, &hv_PyImageGaryPriority);
  TupleSplit(hv_PyImageGaryTypeName, "|", &hv_PyImageGaryTypeName);
  SetMessageTuple(hv_MessageHandle, "PyImageGaryTypeName", hv_PyImageGaryTypeName);
  SetMessageTuple(hv_MessageHandle, "PyImageGaryPriority", hv_PyImageGaryPriority);


  //
  //
  //
  //
  //
  return;
}

void IniMapFile (HTuple hv_FileNames, HTuple hv_Filesizes, HTuple *hv_Filehandles)
{

  // Local iconic variables

  // Local control variables
  HTuple  hv_filemappingMax, hv_Index, hv_Filehandle;

  //global tuple g_filemappingMax
  hv_filemappingMax = ExpGetGlobalVar_g_filemappingMax();
  //
  (*hv_Filehandles) = HTuple();
  //
  if (0 != ((hv_FileNames.TupleLength())==(hv_Filesizes.TupleLength())))
  {
    TupleString(hv_FileNames, "#", &hv_FileNames);
    TupleString(hv_Filesizes, "#", &hv_Filesizes);
    TupleNumber(hv_Filesizes, &hv_Filesizes);
    {
    HTuple end_val9 = (hv_FileNames.TupleLength())-1;
    HTuple step_val9 = 1;
    for (hv_Index=0; hv_Index.Continue(end_val9, step_val9); hv_Index += step_val9)
    {
      ExOpenfilemapping(0, 0, HTuple(hv_FileNames[hv_Index]), HTuple(hv_Filesizes[hv_Index]), 
          &hv_Filehandle);
      //
      if (0 != (HTuple(hv_Filehandle>hv_filemappingMax).TupleOr(hv_Filehandle<0)))
      {
        ExCreatefilemapping(0, 4, 0, HTuple(hv_Filesizes[hv_Index]), HTuple(hv_FileNames[hv_Index]), 
            &hv_Filehandle);
      }
      if (0 != (((hv_Filehandle.TupleInt())-(hv_filemappingMax.TupleInt()))>0))
      {
        throw HalconCpp::HException("createfilemapping,error");
      }
      if (0 != ((hv_Filehandle.TupleInt())<0))
      {
        throw HalconCpp::HException("createfilemapping,error");
      }
      (*hv_Filehandles) = (*hv_Filehandles).TupleConcat(hv_Filehandle);
    }
    }
  }
  //
  return;
}

void Init_SideMeasurementDetection (HTuple hv_CurrentScheme, HTuple hv_CheckParam, 
    HTuple hv_MessageHandle)
{

  // Local iconic variables
  HObject  ho_DiameterRect1, ho_DiameterRect2, ho_GuideRect1;
  HObject  ho_GuideRect2;

  // Local control variables
  HTuple  hv_resolutionratio, hv_ClawRectstr, hv_Substrings;
  HTuple  hv_ClawRectVal, hv_DiameterMeasureW_mm, hv_GuidepinMeasureW_mm;
  HTuple  hv_DiameterVal, hv_Diameter_offset, hv_DiameterMinMax;
  HTuple  hv_GuidepinVal, hv_Guidepin_offset, hv_GuidepinMinMax;

  GetMessageTuple(hv_MessageHandle, "resolutionratio", &hv_resolutionratio);
  //束腰区域
  load_config_ValByType(hv_CurrentScheme, HTuple(hv_CheckParam[0]), "夹爪区域", "rectangle1", 
      "210,1000,1425,1490", &hv_ClawRectstr);
  TupleSplit(hv_ClawRectstr, ",", &hv_Substrings);
  TupleNumber(hv_Substrings, &hv_ClawRectVal);
  SetMessageTuple(hv_MessageHandle, "ClawRectVal", hv_ClawRectVal);

  load_config_number(hv_CurrentScheme, HTuple(hv_CheckParam[0]), "直径测量宽度(mm)", 
      5, &hv_DiameterMeasureW_mm);
  hv_DiameterMeasureW_mm = hv_DiameterMeasureW_mm/hv_resolutionratio;
  SetMessageTuple(hv_MessageHandle, "DiameterMeasureW_mm", hv_DiameterMeasureW_mm);
  load_config_number(hv_CurrentScheme, HTuple(hv_CheckParam[0]), "导针间距测量宽度(mm)", 
      1, &hv_GuidepinMeasureW_mm);
  hv_GuidepinMeasureW_mm = hv_GuidepinMeasureW_mm/hv_resolutionratio;
  SetMessageTuple(hv_MessageHandle, "GuidepinMeasureW_mm", hv_GuidepinMeasureW_mm);
  //gen_rectangle1 (DiameterRect, ClawRectVal[0], ClawRectVal[1]-DiameterMeasureW_mm, ClawRectVal[2], ClawRectVal[1])
  GenRectangle1(&ho_DiameterRect1, HTuple(hv_ClawRectVal[0]), HTuple(hv_ClawRectVal[1])-hv_DiameterMeasureW_mm, 
      (1.0*(HTuple(hv_ClawRectVal[2])+HTuple(hv_ClawRectVal[0])))/2, HTuple(hv_ClawRectVal[1]));
  GenRectangle1(&ho_DiameterRect2, (1.0*(HTuple(hv_ClawRectVal[2])+HTuple(hv_ClawRectVal[0])))/2, 
      HTuple(hv_ClawRectVal[1])-hv_DiameterMeasureW_mm, HTuple(hv_ClawRectVal[2]), 
      HTuple(hv_ClawRectVal[1]));
  SetMessageObj(ho_DiameterRect1, hv_MessageHandle, "DiameterRect1");
  SetMessageObj(ho_DiameterRect2, hv_MessageHandle, "DiameterRect2");

  //gen_rectangle1 (GuideRect, ClawRectVal[0], ClawRectVal[3], ClawRectVal[2], ClawRectVal[3]+GuidepinMeasureW_mm)
  GenRectangle1(&ho_GuideRect1, HTuple(hv_ClawRectVal[0]), HTuple(hv_ClawRectVal[3]), 
      (1.0*(HTuple(hv_ClawRectVal[0])+HTuple(hv_ClawRectVal[2])))/2, HTuple(hv_ClawRectVal[3])+hv_GuidepinMeasureW_mm);
  GenRectangle1(&ho_GuideRect2, (1.0*(HTuple(hv_ClawRectVal[0])+HTuple(hv_ClawRectVal[2])))/2, 
      HTuple(hv_ClawRectVal[3]), HTuple(hv_ClawRectVal[2]), HTuple(hv_ClawRectVal[3])+hv_GuidepinMeasureW_mm);
  SetMessageObj(ho_GuideRect1, hv_MessageHandle, "GuideRect1");
  SetMessageObj(ho_GuideRect2, hv_MessageHandle, "GuideRect2");



  load_config_number(hv_CurrentScheme, HTuple(hv_CheckParam[0]), "直径", 18, &hv_DiameterVal);
  load_config_number(hv_CurrentScheme, HTuple(hv_CheckParam[0]), "直径容差", 0.5, 
      &hv_Diameter_offset);
  hv_DiameterMinMax.Clear();
  hv_DiameterMinMax.Append(hv_DiameterVal-hv_Diameter_offset);
  hv_DiameterMinMax.Append(hv_DiameterVal+hv_Diameter_offset);
  SetMessageTuple(hv_MessageHandle, "DiameterMinMax", hv_DiameterMinMax);

  load_config_number(hv_CurrentScheme, HTuple(hv_CheckParam[0]), "导针间距", 7, &hv_GuidepinVal);
  load_config_number(hv_CurrentScheme, HTuple(hv_CheckParam[0]), "导针间距容差", 
      1, &hv_Guidepin_offset);
  hv_GuidepinMinMax.Clear();
  hv_GuidepinMinMax.Append(hv_GuidepinVal-hv_Guidepin_offset);
  hv_GuidepinMinMax.Append(hv_GuidepinVal+hv_Guidepin_offset);
  SetMessageTuple(hv_MessageHandle, "GuidepinMinMax", hv_GuidepinMinMax);

  return;
}

void Check_Side (HObject ho_Image, HTuple hv_ShowHide, HTuple hv_WindowHandle, HTuple hv_MessageHandle, 
    HTuple *hv_ResultInfo, HTuple *hv_WindowInfo, HTupleVector/*{eTupleVector,Dim=2}*/ *hvec_FeatureVals)
{

  // Local iconic variables
  HObject  ho_GuideRect1, ho_GuideRect2, ho_DiameterRect1;
  HObject  ho_DiameterRect2, ho_ImageReduced, ho_Region1, ho_Region2;
  HObject  ho_GRegion1, ho_GRegion2;

  // Local control variables
  HTuple  hv_Width, hv_Height, hv_resolutionratio;
  HTuple  hv_MinDistance, hv_Row1, hv_Column1, hv_Row2, hv_Column2;
  HTuple  hv_DiameterDistance, hv_GArea1, hv_GRow1, hv_GColumn1;
  HTuple  hv_GArea2, hv_GRow2, hv_GColumn2, hv_GDistance;
  HTuple  hv_GuideDistance, hv_GuidepinMinMax, hv_DiameterMinMax;

  (*hv_ResultInfo) = "OK";
  (*hv_WindowInfo) = HTuple();
  (*hvec_FeatureVals) = HTupleVector(2);

  GetImageSize(ho_Image, &hv_Width, &hv_Height);
  //get_message_tuple (MessageHandle, 'UsePythonCheck', UsePythonCheck)
  GetMessageObj(&ho_GuideRect1, hv_MessageHandle, "GuideRect1");
  GetMessageObj(&ho_GuideRect2, hv_MessageHandle, "GuideRect2");
  GetMessageObj(&ho_DiameterRect1, hv_MessageHandle, "DiameterRect1");
  GetMessageObj(&ho_DiameterRect2, hv_MessageHandle, "DiameterRect2");

  GetMessageTuple(hv_MessageHandle, "resolutionratio", &hv_resolutionratio);
  if (0 != hv_ShowHide)
  {
    DispObj(ho_GuideRect1, hv_WindowHandle);
    DispObj(ho_GuideRect2, hv_WindowHandle);
    DispObj(ho_DiameterRect1, hv_WindowHandle);
    DispObj(ho_DiameterRect2, hv_WindowHandle);
  }
  ReduceDomain(ho_Image, ho_DiameterRect1, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_Region1, 128, 255);
  ReduceDomain(ho_Image, ho_DiameterRect2, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_Region2, 128, 255);
  DistanceRrMin(ho_Region1, ho_Region2, &hv_MinDistance, &hv_Row1, &hv_Column1, &hv_Row2, 
      &hv_Column2);
  if (0 != (HTuple(hv_MinDistance[0])<2))
  {
    (*hv_ResultInfo) = "空料";
    return;
  }
  hv_DiameterDistance = hv_MinDistance*hv_resolutionratio;
  if (0 != hv_ShowHide)
  {
    DispLine(hv_WindowHandle, hv_Row1, hv_Column1, hv_Row2, hv_Column2);
    DispCross(hv_WindowHandle, hv_Row1.TupleConcat(hv_Row2), hv_Column1.TupleConcat(hv_Column2), 
        56, HTuple(45).TupleRad());
  }


  ReduceDomain(ho_Image, ho_GuideRect1, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_GRegion1, 0, 128);
  AreaCenter(ho_GRegion1, &hv_GArea1, &hv_GRow1, &hv_GColumn1);
  ReduceDomain(ho_Image, ho_GuideRect2, &ho_ImageReduced);
  Threshold(ho_ImageReduced, &ho_GRegion2, 0, 128);
  AreaCenter(ho_GRegion2, &hv_GArea2, &hv_GRow2, &hv_GColumn2);
  if (0 != (HTuple((hv_GArea1.TupleLength())==0).TupleOr((hv_GArea2.TupleLength())==0)))
  {
    (*hv_ResultInfo) = "空料";
    return;
  }
  else if (0 != (HTuple((hv_GArea1.TupleSum())<2).TupleOr((hv_GArea2.TupleSum())<2)))
  {
    (*hv_ResultInfo) = "空料";
    return;
  }
  DistancePp(hv_GRow1, hv_GColumn1, hv_GRow2, hv_GColumn2, &hv_GDistance);
  if (0 != (hv_GDistance==0))
  {
    (*hv_ResultInfo) = "空料";
    return;
  }
  hv_GuideDistance = hv_GDistance*hv_resolutionratio;
  if (0 != hv_ShowHide)
  {
    DispLine(hv_WindowHandle, hv_GRow1, hv_GColumn1, hv_GRow2, hv_GColumn2);
    DispCross(hv_WindowHandle, hv_GRow1.TupleConcat(hv_GRow2), hv_GColumn1.TupleConcat(hv_GColumn2), 
        56, HTuple(45).TupleRad());
  }
  GetMessageTuple(hv_MessageHandle, "GuidepinMinMax", &hv_GuidepinMinMax);
  GetMessageTuple(hv_MessageHandle, "DiameterMinMax", &hv_DiameterMinMax);
  (*hv_WindowInfo) = (*hv_WindowInfo).TupleConcat(((((("直径:"+hv_DiameterDistance)+"[")+HTuple(hv_DiameterMinMax[0]))+",")+HTuple(hv_DiameterMinMax[1]))+"]");
  (*hv_WindowInfo) = (*hv_WindowInfo).TupleConcat(((((("导针间距:"+hv_GuideDistance)+"[")+HTuple(hv_GuidepinMinMax[0]))+",")+HTuple(hv_GuidepinMinMax[1]))+"]");


  if (0 != (HTuple(HTuple(hv_DiameterMinMax[0])<hv_DiameterDistance).TupleAnd(HTuple(hv_DiameterMinMax[1])>hv_DiameterDistance)))
  {

  }
  else
  {
    (*hv_ResultInfo) = "NG";
    return;
  }


  if (0 != (HTuple(HTuple(hv_GuidepinMinMax[0])<hv_GuideDistance).TupleAnd(HTuple(hv_GuidepinMinMax[1])>hv_GuideDistance)))
  {

  }
  else
  {
    (*hv_ResultInfo) = "NG";
    return;
  }
  (*hv_ResultInfo) = "OK";


  return;
}

void Init_OCRFlawDetection (HTuple hv_CurrentScheme, HTuple hv_CheckParam, HTuple hv_DirPath, 
    HTuple hv_MessageHandle)
{

  // Local iconic variables
  HObject  ho_ModelContours, ho_Region1, ho_RegionUnion;

  // Local control variables
  HTuple  hv_ImageAdd, hv_ProductHeight, hv_PosRowMax;
  HTuple  hv_Resolution_H, hv_PosRowMin, hv_DirName, hv_OCRSigns;
  HTuple  ExpTmpLocalVar_g_OCRSignsIndexModel, hv_Index, hv_val;
  HTuple  hv_OCRval, hv_OCRDirection, hv_shmfile, hv_shmModelId;
  HTuple  hv_Row1, hv_Column1, hv_Row2, hv_Column2, hv_shmLen;
  HTuple  hv_shmps, hv_dfmfile, hv_dfmModelId, hv_dfmLen;
  HTuple  hv_dfmps, hv_Rectval, hv_TextModel, hv_val1, hv_OcrHandle;

  //获得预处理图像的分割区域
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, HTuple(hv_CheckParam[0]), 
      "图像增强", "ImageAdd", 0.5, &hv_ImageAdd);

  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, HTuple(hv_CheckParam[0]), 
      "产品高度", "ProductHeight", 25, &hv_ProductHeight);

  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, HTuple(hv_CheckParam[0]), 
      "产品最低点", "PosRowMax", 3275, &hv_PosRowMax);
  GetMessageTuple(hv_MessageHandle, "Resolution_H", &hv_Resolution_H);
  hv_PosRowMin = (hv_PosRowMax-((1.0*hv_ProductHeight)/hv_Resolution_H))-10;
  SetMessageTuple(hv_MessageHandle, "PosRowMin", hv_PosRowMin);


  GetCurrentDir(&hv_DirName);
  load_config_split(hv_CurrentScheme, HTuple(hv_CheckParam[0]), "OCRSigns", "uF|V", 
      "|", &hv_OCRSigns);
  SetMessageTuple(hv_MessageHandle, "OCRSigns", hv_OCRSigns);



  //global tuple g_OCRSignsIndexModel

  {
  HTuple end_val19 = (hv_OCRSigns.TupleLength())-1;
  HTuple step_val19 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val19, step_val19); hv_Index += step_val19)
  {
    load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, HTuple(hv_CheckParam[0]), 
        HTuple(hv_OCRSigns[hv_Index])+"结果启用", HTuple(hv_OCRSigns[hv_Index])+"_ResultUse", 
        1, &hv_val);
    load_config_set_message_Str(hv_MessageHandle, hv_CurrentScheme, HTuple(hv_CheckParam[0]), 
        HTuple(hv_OCRSigns[hv_Index])+"值", HTuple(hv_OCRSigns[hv_Index])+"_val", 
        "120", &hv_OCRval);
    load_config_set_message_Str(hv_MessageHandle, hv_CurrentScheme, HTuple(hv_CheckParam[0]), 
        HTuple(hv_OCRSigns[hv_Index])+"shmdfm", HTuple(hv_OCRSigns[hv_Index])+"_shmdfm", 
        "dfm", &hv_val);

    //load_config_set_message_Str (MessageHandle, CurrentScheme, CheckParam[0], 'OCR文件路径', 'OCRFilePath', 35, OCRFilePath)
    //方向(0,90,180,270)
    load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, HTuple(hv_CheckParam[0]), 
        HTuple(hv_OCRSigns[hv_Index])+"方向", HTuple(hv_OCRSigns[hv_Index])+"_Direction", 
        0, &hv_OCRDirection);

    load_config_set_message_Str(hv_MessageHandle, hv_CurrentScheme, HTuple(hv_CheckParam[0]), 
        HTuple(hv_OCRSigns[hv_Index])+"_shmFile", HTuple(hv_OCRSigns[hv_Index])+"_shmFile", 
        HTuple(hv_OCRSigns[hv_Index])+"_model.shm", &hv_shmfile);
    ReadShapeModel((hv_DirName+"\\")+hv_shmfile, &hv_shmModelId);
    ExpTmpLocalVar_g_OCRSignsIndexModel = ExpGetGlobalVar_g_OCRSignsIndexModel().TupleConcat(hv_shmModelId);
    ExpSetGlobalVar_g_OCRSignsIndexModel(ExpTmpLocalVar_g_OCRSignsIndexModel);
    SetMessageTuple(hv_MessageHandle, HTuple(hv_OCRSigns[hv_Index])+"_shmModelId", 
        hv_shmModelId);

    SetMessageTuple(hv_MessageHandle, HTuple(hv_OCRSigns[hv_Index])+"_shmModelId_CloseClear", 
        "clear_shape_model");
    GetShapeModelContours(&ho_ModelContours, hv_shmModelId, 1);
    GenRegionContourXld(ho_ModelContours, &ho_Region1, "filled");
    Union1(ho_Region1, &ho_RegionUnion);
    SmallestRectangle1(ho_RegionUnion, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
    hv_shmLen = hv_OCRval.TupleStrlen();
    hv_shmps.Clear();
    hv_shmps.Append((-hv_Row2)-25);
    hv_shmps.Append((-(hv_Column2+3))*(hv_shmLen+1));
    hv_shmps.Append(hv_Row2+10);
    hv_shmps.Append(hv_Column2);
    SetMessageTuple(hv_MessageHandle, HTuple(hv_OCRSigns[hv_Index])+"_shmps", hv_shmps);

    load_config_set_message_Str(hv_MessageHandle, hv_CurrentScheme, HTuple(hv_CheckParam[0]), 
        HTuple(hv_OCRSigns[hv_Index])+"_dfmFile", HTuple(hv_OCRSigns[hv_Index])+"_dfmFile", 
        HTuple(hv_OCRSigns[hv_Index])+"_model.dfm", &hv_dfmfile);
    ReadDeformableModel((hv_DirPath+"\\")+hv_dfmfile, &hv_dfmModelId);
    ExpTmpLocalVar_g_OCRSignsIndexModel = ExpGetGlobalVar_g_OCRSignsIndexModel().TupleConcat(hv_dfmModelId);
    ExpSetGlobalVar_g_OCRSignsIndexModel(ExpTmpLocalVar_g_OCRSignsIndexModel);
    SetMessageTuple(hv_MessageHandle, HTuple(hv_OCRSigns[hv_Index])+"_dfmModelId", 
        hv_dfmModelId);
    SetMessageTuple(hv_MessageHandle, HTuple(hv_OCRSigns[hv_Index])+"_dfmModelId_CloseClear", 
        "clear_deformable_model");
    GetDeformableModelContours(&ho_ModelContours, hv_dfmModelId, 1);
    GenRegionContourXld(ho_ModelContours, &ho_Region1, "filled");
    Union1(ho_Region1, &ho_RegionUnion);
    SmallestRectangle1(ho_RegionUnion, &hv_Row1, &hv_Column1, &hv_Row2, &hv_Column2);
    hv_dfmLen = hv_OCRval.TupleStrlen();
    hv_dfmps.Clear();
    hv_dfmps.Append((-hv_Row2)-25);
    hv_dfmps.Append((-(hv_Column2+3))*(hv_dfmLen+1));
    hv_dfmps.Append(hv_Row2+10);
    hv_dfmps.Append(hv_Column2);
    SetMessageTuple(hv_MessageHandle, HTuple(hv_OCRSigns[hv_Index])+"_dfmps", hv_dfmps);

    load_config_split_numeber(hv_CurrentScheme, HTuple(hv_CheckParam[0]), HTuple(hv_OCRSigns[hv_Index])+"_RectVal", 
        "2591,1736,2718,2005", ",", &hv_Rectval);
    SetMessageTuple(hv_MessageHandle, HTuple(hv_OCRSigns[hv_Index])+"_RectVal", hv_Rectval);
    CreateTextModelReader("manual", HTuple(), &hv_TextModel);
    load_config_number(hv_CurrentScheme, HTuple(hv_CheckParam[0]), HTuple(hv_OCRSigns[hv_Index])+"_亮黑", 
        0, &hv_val1);
    if (0 != (hv_val1==0))
    {
      SetTextModelParam(hv_TextModel, "polarity", "light_on_dark");
    }
    else
    {
      SetTextModelParam(hv_TextModel, "polarity", "dark_on_light");
    }

    SetTextModelParam(hv_TextModel, "is_dotprint", "true");
    SetTextModelParam(hv_TextModel, "char_width", 53);
    SetTextModelParam(hv_TextModel, "char_height", 81);
    SetTextModelParam(hv_TextModel, "stroke_width", 8);
    SetTextModelParam(hv_TextModel, "return_punctuation", "false");
    SetTextModelParam(hv_TextModel, "return_separators", "false");
    SetTextModelParam(hv_TextModel, "uppercase_only", "true");
    SetTextModelParam(hv_TextModel, "fragment_size_min", 16);
    SetTextModelParam(hv_TextModel, "eliminate_border_blobs", "true");
    SetTextModelParam(hv_TextModel, "base_line_tolerance", 0.2);
    SetTextModelParam(hv_TextModel, "max_line_num", 1);
    ReadOcrClassMlp("DotPrint_0-9.omc", &hv_OcrHandle);
    SetMessageTuple(hv_MessageHandle, HTuple(hv_OCRSigns[hv_Index])+"OcrHandle", 
        hv_OcrHandle);
    SetMessageTuple(hv_MessageHandle, HTuple(hv_OCRSigns[hv_Index])+"TextModel", 
        hv_TextModel);
    SetMessageTuple(hv_MessageHandle, HTuple(hv_OCRSigns[hv_Index])+"OcrHandle_CloseClear", 
        "clear_ocr_class_mlp");
    SetMessageTuple(hv_MessageHandle, HTuple(hv_OCRSigns[hv_Index])+"TextModel_CloseClear", 
        "clear_text_model");

  }
  }







  //load_config_set_message_Number (MessageHandle, CurrentScheme, CheckParam[0], 'OCR文件路径', 'FilePath', 35, FilePath)





}

void Check_Sur (HObject ho_PreprocessImage, HTuple hv_ShowHide, HTuple hv_WindowHandle, 
    HTuple hv_MessageHandle, HTuple *hv_ResultInfo, HTuple *hv_WindowInfo, HTupleVector/*{eTupleVector,Dim=2}*/ *hvec_FeatureVals)
{

  // Local iconic variables
  HObject  ho_PreprocessingRegion, ho_ImageReduced;
  HObject  ho_ErrorRegion;

  // Local control variables
  HTuple  hv_Width, hv_Height, hv_Pointer, hv_Type;
  HTuple  hv_UsePythonCheck, hv_ThresholdMinGray, hv_ThresholdMaxGray;
  HTuple  hv_Area, hv_Row, hv_Column, hv_ErrorAreaMax;

  (*hv_ResultInfo) = "OK";
  (*hv_WindowInfo) = HTuple();
  (*hvec_FeatureVals) = HTupleVector(2);

  GetImageSize(ho_PreprocessImage, &hv_Width, &hv_Height);

  GetImagePointer1(ho_PreprocessImage, &hv_Pointer, &hv_Type, &hv_Width, &hv_Height);
  GetMessageTuple(hv_MessageHandle, "UsePythonCheck", &hv_UsePythonCheck);
  SetMessageTuple(hv_MessageHandle, "PythonImageInfo", ((HTuple(0).TupleConcat(hv_Pointer)).TupleConcat(hv_Width)).TupleConcat(hv_Height));


  GetMessageObj(&ho_PreprocessingRegion, hv_MessageHandle, "PreprocessingRegion");
  if (0 != hv_ShowHide)
  {
    DispObj(ho_PreprocessingRegion, hv_WindowHandle);
  }
  ReduceDomain(ho_PreprocessImage, ho_PreprocessingRegion, &ho_ImageReduced);
  GetMessageTuple(hv_MessageHandle, "ThresholdMinGray", &hv_ThresholdMinGray);
  GetMessageTuple(hv_MessageHandle, "ThresholdMaxGray", &hv_ThresholdMaxGray);
  Threshold(ho_ImageReduced, &ho_ErrorRegion, hv_ThresholdMinGray, hv_ThresholdMaxGray);
  AreaCenter(ho_ErrorRegion, &hv_Area, &hv_Row, &hv_Column);
  GetMessageTuple(hv_MessageHandle, "ErrorAreaMax", &hv_ErrorAreaMax);
  if (0 != (HTuple(hv_Area>0).TupleAnd(hv_ShowHide)))
  {
    DispObj(ho_ErrorRegion, hv_WindowHandle);
  }
  if (0 != (hv_Area>hv_ErrorAreaMax))
  {
    (*hv_ResultInfo) = "NG";
  }
  (*hv_WindowInfo) = "漏光:"+hv_Area;

  return;
}

void Init_BottomSurfaceDetection (HTuple hv_CurrentScheme, HTuple hv_CheckParam, 
    HTuple hv_MessageHandle)
{

  // Local iconic variables
  HObject  ho_EmptyRegion, ho_CheckRegion;

  // Local control variables
  HTuple  hv_DiameterVal, hv_Diameter_offset, hv_DiameterMinMax;
  HTuple  hv_ProductCentre, hv_resolutionratio, hv_EmptyRegionVals;
  HTuple  hv_wh, hv_CheckRegionVals, hv_thresholdval, hv_erosion_dilation;


  load_config_number(hv_CurrentScheme, HTuple(hv_CheckParam[0]), "直径", 18, &hv_DiameterVal);
  load_config_number(hv_CurrentScheme, HTuple(hv_CheckParam[0]), "直径容差", 0.5, 
      &hv_Diameter_offset);
  hv_DiameterMinMax.Clear();
  hv_DiameterMinMax.Append(hv_DiameterVal-hv_Diameter_offset);
  hv_DiameterMinMax.Append(hv_DiameterVal+hv_Diameter_offset);
  SetMessageTuple(hv_MessageHandle, "DiameterMinMax", hv_DiameterMinMax);

  //load_config_number (CurrentScheme, CurrentScheme[0], '导针间距', 6, GuidepinVal)
  //load_config (CurrentScheme, CurrentScheme[0], '导针间距容差', 0.5, Guidepin_offset)
  //GuidepinMinMax := [GuidepinVal-Guidepin_offset,GuidepinVal+Guidepin_offset]
  //set_message_tuple (MessageHandle, 'GuidepinMinMax', GuidepinMinMax)

  load_config_split_numeber(hv_CurrentScheme, HTuple(hv_CheckParam[0]), "产品中心", 
      "1190,1193", ",", &hv_ProductCentre);
  SetMessageTuple(hv_MessageHandle, "ProductCentre", hv_ProductCentre);
  GetMessageTuple(hv_MessageHandle, "resolutionratio", &hv_resolutionratio);
  //生成判断是否空料的区域
  hv_EmptyRegionVals.Clear();
  hv_EmptyRegionVals.Append(HTuple(hv_ProductCentre[0]));
  hv_EmptyRegionVals.Append(HTuple(hv_ProductCentre[1])-(((1.0*hv_DiameterVal)/hv_resolutionratio)/2));
  hv_EmptyRegionVals.Append(HTuple(hv_ProductCentre[0]));
  hv_EmptyRegionVals.Append(HTuple(hv_ProductCentre[1])+(((1.0*hv_DiameterVal)/hv_resolutionratio)/2));
  GenRectangle1(&ho_EmptyRegion, HTuple(hv_EmptyRegionVals[0]), HTuple(hv_EmptyRegionVals[1]), 
      HTuple(hv_EmptyRegionVals[2]), HTuple(hv_EmptyRegionVals[3]));
  SetMessageObj(ho_EmptyRegion, hv_MessageHandle, "EmptyRegion");
  SetMessageTuple(hv_MessageHandle, "EmptyRegionVals", hv_EmptyRegionVals);

  //生成产品预处理检测区域
  hv_wh = (((1.0*hv_DiameterVal)/hv_resolutionratio)/2)+100;
  hv_CheckRegionVals.Clear();
  hv_CheckRegionVals.Append(HTuple(hv_ProductCentre[0])-hv_wh);
  hv_CheckRegionVals.Append(HTuple(hv_ProductCentre[1])-hv_wh);
  hv_CheckRegionVals.Append(HTuple(hv_ProductCentre[0])+hv_wh);
  hv_CheckRegionVals.Append(HTuple(hv_ProductCentre[1])+hv_wh);
  GenRectangle1(&ho_CheckRegion, HTuple(hv_CheckRegionVals[0]), HTuple(hv_CheckRegionVals[1]), 
      HTuple(hv_CheckRegionVals[2]), HTuple(hv_CheckRegionVals[3]));
  SetMessageObj(ho_CheckRegion, hv_MessageHandle, "CheckRegion");
  SetMessageTuple(hv_MessageHandle, "CheckRegionVals", hv_CheckRegionVals);




  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, HTuple(hv_CheckParam[0]), 
      "thresholdval", "thresholdval", 140, &hv_thresholdval);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, HTuple(hv_CheckParam[0]), 
      "erosion_dilation", "erosion_dilation", 15, &hv_erosion_dilation);


  return;
}

void InitGlobalOnce ()
{

  // Local iconic variables

  // Local control variables
  HTuple  ExpTmpLocalVar_g_filemappingMax, hv_DirName;
  HTuple  hv_SystemPath, hv_filemappingMax, ExpTmpLocalVar_g_OCRSignsIndexModel;

  //global tuple g_filemappingMax
  GetCurrentDir(&hv_DirName);
  hv_SystemPath = hv_DirName+"/SystemConfiguration/Global.ini";
  load_config_number(hv_SystemPath, "共享内存区", "数量MAX", 1024, &hv_filemappingMax);
  ExInitfilemapping(hv_filemappingMax);
  ExpTmpLocalVar_g_filemappingMax = hv_filemappingMax.TupleInt();
  ExpSetGlobalVar_g_filemappingMax(ExpTmpLocalVar_g_filemappingMax);
  //global tuple g_OCRSignsIndexModel
  ExpTmpLocalVar_g_OCRSignsIndexModel = HTuple();
  ExpSetGlobalVar_g_OCRSignsIndexModel(ExpTmpLocalVar_g_OCRSignsIndexModel);

  return;
}

void SaveImageThread (HObject ho_Image, HTuple hv_Format, HTuple hv_fillcolor, HTuple hv_filename)
{

  // Local control variables
  HTuple  hv_ThreadID;

  // +++ Threading variables 
  HDevThread*         hcppthread_handle;
  HDevThreadContext   hcppthread_context; // <-signals begin of procedure

  // Create a thread instance
  hcppthread_handle = new HDevThread(hcppthread_context,
              (void*)HDevExportCpp::_hcppthread_write_image,4,0);
  // Set thread procedure call arguments 
  hcppthread_handle->SetInputIconicParamObject(0,ho_Image);
  hcppthread_handle->SetInputCtrlParamTuple(1,hv_Format);
  hcppthread_handle->SetInputCtrlParamTuple(2,hv_fillcolor);
  hcppthread_handle->SetInputCtrlParamTuple(3,hv_filename);

  // Start proc line in thread
  hcppthread_handle->ParStart(&hv_ThreadID);

  return;
}

void Init_BottomConvexDetection (HTuple hv_CurrentScheme, HTuple hv_lsCheckParam, 
    HTuple hv_MessageHandle)
{

  // Local iconic variables
  HObject  ho_PreprocessingRegion;

  // Local control variables
  HTuple  hv_PreprocessingRegionstr, hv_vals, hv_ThresholdMinGray;
  HTuple  hv_ThresholdMaxGray, hv_ErrorAreaMax;

  load_config_ValByType(hv_CurrentScheme, HTuple(hv_lsCheckParam[0]), "PreprocessingRegion", 
      "rectangle1", "585,1246,1197,1421", &hv_PreprocessingRegionstr);
  gen_region_byTypeAndStr(&ho_PreprocessingRegion, "rectangle1", hv_PreprocessingRegionstr, 
      &hv_vals);
  SetMessageObj(ho_PreprocessingRegion, hv_MessageHandle, "PreprocessingRegion");

  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, HTuple(hv_lsCheckParam[0]), 
      "缺陷灰度最低值", "ThresholdMinGray", 160, &hv_ThresholdMinGray);
  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, HTuple(hv_lsCheckParam[0]), 
      "缺陷灰度最高值", "ThresholdMaxGray", 255, &hv_ThresholdMaxGray);

  load_config_set_message_Number(hv_MessageHandle, hv_CurrentScheme, HTuple(hv_lsCheckParam[0]), 
      "缺陷像素面积", "ErrorAreaMax", 20, &hv_ErrorAreaMax);


  return;
}

void Check_EinsFeatureExtract (HObject ho_Image, HTuple hv_ShowHide, HTuple hv_WindowHandle, 
    HTuple hv_MessageHandle, HTuple *hv_ResultInfo, HTuple *hv_WindowInfo, HTupleVector/*{eTupleVector,Dim=2}*/ *hvec_FeatureVals)
{

  // Local iconic variables
  HObject  ho_EmptyRegion, ho_ImageReduced1, ho_Region;
  HObject  ho_CheckRegion, ho_Regions, ho_ConnectedRegions;
  HObject  ho_RegionErosion, ho_SelectedRegions, ho_RegionUnion;
  HObject  ho_RegionClosing, ho_RegionOpening, ho_Contours;
  HObject  ho_RegionCentrePoint, ho_Circle, ho_ImageReduced;
  HObject  ho_ImageMean, ho_Regions1, ho_ConnectedRegions4;
  HObject  ho_SelectedRegions3, ho_RegionFillUp, ho_RegionErosion2;
  HObject  ho_RegionDilation2, ho_Circle1, ho_RingRegion, ho_ConnectedRegions5;
  HObject  ho_SelectedRegions4, ho_RegionDilation3, ho_RegionErosion4;
  HObject  ho_ConnectedRegions7, ho_RegionDifference1, ho_RegionDynThresh1;
  HObject  ho_ConnectedRegions3, ho_SelectedRegionsA, ho_Rectangle1;
  HObject  ho_RectangleA1, ho_RegionDifference, ho_SelectedRegionsB;
  HObject  ho_RectangleB1, ho_RegionDilation4, ho_RegionDifference2;
  HObject  ho_RegionUnion1, ho_RegionErosion3, ho_RegionDifference3;
  HObject  ho_ConnectedRegions6, ho_ImageResult;

  // Local control variables
  HTuple  hv_Width, hv_Height, hv_thresholdval;
  HTuple  hv_erosion_dilation, hv_ProductCentre, hv_EmptyRegionVals;
  HTuple  hv_Number, hv_Area, hv_Row6, hv_Column1, hv_CheckRegionVals;
  HTuple  hv_Row, hv_Column, hv_Radius, hv_StartPhi, hv_EndPhi;
  HTuple  hv_PointOrder, hv_Row3, hv_Column3, hv_Radius1;
  HTuple  hv_Area1, hv_Row4, hv_Column4, hv_soldereddotRowA;
  HTuple  hv_soldereddotColumnA, hv_soldereddotRowB, hv_soldereddotColumnB;
  HTuple  hv_angle, hv_degAngleA, hv_degAngleB, hv_RowA, hv_ColumnA;
  HTuple  hv_PhiA, hv_LengthA1, hv_LengthA2, hv_MinDistance;
  HTuple  hv_Row11, hv_Column11, hv_RowB, hv_ColumnB, hv_PhiB;
  HTuple  hv_LengthB1, hv_LengthB2, hv_Area2, hv_Row2, hv_Column2;
  HTuple  hv_AngleA, hv_AngleB, hv_AngleAB, hv_degAngleAB;
  HTuple  hv_DistanceMinA, hv_DistanceMaxA, hv_DistanceMinB;
  HTuple  hv_DistanceMaxB, hv_soldereddotRow, hv_soldereddotColumn;
  HTuple  hv_AreaA, hv_AreaB, hv_dotAngle, hv_degdotAngle;
  HTuple  hv_Angle, hv_soldereddotAngle, hv_ImageInfoval;
  HTuple  hv_PyResultVal, hv_PyResultInfo, hv_PyWindowInfo;
  HTupleVector  hvec_PyFeatureVals(2);

  (*hv_ResultInfo) = "OK";
  (*hv_WindowInfo) = HTuple();
  (*hvec_FeatureVals) = HTupleVector(2);

  //增加划定ROI区域
  //结果信息

  GetImageSize(ho_Image, &hv_Width, &hv_Height);
  //初始化发送的角度为0
  SetMessageTuple(hv_MessageHandle, "Result_Angle", 0);


  GetMessageTuple(hv_MessageHandle, "thresholdval", &hv_thresholdval);
  GetMessageTuple(hv_MessageHandle, "erosion_dilation", &hv_erosion_dilation);


  //'产品中心'
  GetMessageTuple(hv_MessageHandle, "ProductCentre", &hv_ProductCentre);
  GetMessageObj(&ho_EmptyRegion, hv_MessageHandle, "EmptyRegion");
  //判断是否空料的区域
  GetMessageObj(&ho_EmptyRegion, hv_MessageHandle, "EmptyRegion");
  GetMessageTuple(hv_MessageHandle, "EmptyRegionVals", &hv_EmptyRegionVals);
  ReduceDomain(ho_Image, ho_EmptyRegion, &ho_ImageReduced1);
  Threshold(ho_ImageReduced1, &ho_Region, 0, 230);
  CountObj(ho_Region, &hv_Number);
  if (0 != (hv_Number>=1))
  {
    AreaCenter(ho_Region, &hv_Area, &hv_Row6, &hv_Column1);
    if (0 != (hv_Area<200))
    {
      (*hv_ResultInfo) = "空料";
      return;
    }
  }
  //获取有效检测区域
  GetMessageObj(&ho_CheckRegion, hv_MessageHandle, "CheckRegion");
  GetMessageTuple(hv_MessageHandle, "CheckRegionVals", &hv_CheckRegionVals);
  AutoThreshold(ho_Image, &ho_Regions, 2);
  Connection(ho_Regions, &ho_ConnectedRegions);
  ErosionCircle(ho_ConnectedRegions, &ho_RegionErosion, 3.5);
  Connection(ho_RegionErosion, &ho_ConnectedRegions);
  SelectShape(ho_ConnectedRegions, &ho_SelectedRegions, (((HTuple("row1").Append("column1")).Append("row2")).Append("column2")), 
      "and", ((HTuple(hv_CheckRegionVals[0]).TupleConcat(HTuple(hv_CheckRegionVals[1]))).TupleConcat(HTuple(hv_CheckRegionVals[0]))).TupleConcat(HTuple(hv_CheckRegionVals[1])), 
      ((HTuple(hv_CheckRegionVals[2]).TupleConcat(HTuple(hv_CheckRegionVals[3]))).TupleConcat(HTuple(hv_CheckRegionVals[2]))).TupleConcat(HTuple(hv_CheckRegionVals[3])));
  Union1(ho_SelectedRegions, &ho_RegionUnion);
  FillUp(ho_RegionUnion, &ho_RegionUnion);
  ClosingCircle(ho_RegionUnion, &ho_RegionClosing, 100);
  OpeningCircle(ho_RegionClosing, &ho_RegionOpening, 200);
  GenContourRegionXld(ho_RegionOpening, &ho_Contours, "border");
  FitCircleContourXld(ho_Contours, "algebraic", -1, 0, 0, 3, 2, &hv_Row, &hv_Column, 
      &hv_Radius, &hv_StartPhi, &hv_EndPhi, &hv_PointOrder);
  GenCircle(&ho_RegionClosing, hv_Row, hv_Column, hv_Radius);

  //smallest_circle (RegionClosing, Row, Column, Radius)

  if (0 != hv_ShowHide)
  {
    DispCross(hv_WindowHandle, hv_Row, hv_Column, 56, HTuple(45).TupleRad());
  }

  GenRegionPoints(&ho_RegionCentrePoint, hv_Row, hv_Column);
  GenCircle(&ho_Circle, hv_Row, hv_Column, hv_Radius-60);

  ReduceDomain(ho_Image, ho_Circle, &ho_ImageReduced);

  MeanImage(ho_ImageReduced, &ho_ImageMean, 29, 29);
  AutoThreshold(ho_ImageMean, &ho_Regions1, 2);
  Connection(ho_Regions1, &ho_ConnectedRegions4);
  SelectShapeStd(ho_ConnectedRegions4, &ho_SelectedRegions3, "max_area", 100);
  FillUp(ho_SelectedRegions3, &ho_RegionFillUp);
  ErosionCircle(ho_SelectedRegions3, &ho_RegionErosion2, 20);
  DilationCircle(ho_RegionErosion2, &ho_RegionDilation2, 20);
  SmallestCircle(ho_RegionDilation2, &hv_Row3, &hv_Column3, &hv_Radius1);
  GenCircle(&ho_Circle1, hv_Row3, hv_Column3, hv_Radius1+5);
  Difference(ho_ConnectedRegions4, ho_Circle1, &ho_RingRegion);
  Connection(ho_RingRegion, &ho_ConnectedRegions5);
  SelectShapeStd(ho_ConnectedRegions5, &ho_SelectedRegions4, "max_area", 100);
  DilationCircle(ho_SelectedRegions4, &ho_RegionDilation3, 20);
  ErosionCircle(ho_ConnectedRegions5, &ho_RegionErosion4, 3.5);
  Connection(ho_RegionErosion4, &ho_ConnectedRegions7);
  Difference(ho_ConnectedRegions7, ho_RegionDilation3, &ho_RegionDifference1);

  DynThreshold(ho_ImageReduced, ho_ImageMean, &ho_RegionDynThresh1, 20, "light");
  Connection(ho_RegionDynThresh1, &ho_ConnectedRegions3);
  AreaCenter(ho_ConnectedRegions3, &hv_Area1, &hv_Row4, &hv_Column4);

  hv_soldereddotRowA = HTuple();
  hv_soldereddotColumnA = HTuple();
  hv_soldereddotRowB = HTuple();
  hv_soldereddotColumnB = HTuple();
  hv_angle = HTuple();
  hv_degAngleA = -1;
  hv_degAngleB = -1;
  if (0 != ((hv_Area1.TupleLength())>=2))
  {
    SelectShapeStd(ho_ConnectedRegions3, &ho_SelectedRegionsA, "max_area", 100);
    SmallestRectangle2(ho_SelectedRegionsA, &hv_RowA, &hv_ColumnA, &hv_PhiA, &hv_LengthA1, 
        &hv_LengthA2);
    if (0 != (((hv_LengthA1-hv_LengthA2).TupleAbs())>20))
    {
      if (0 != (hv_LengthA1>hv_LengthA2))
      {
        GenRectangle2(&ho_Rectangle1, hv_RowA, hv_ColumnA, hv_PhiA, hv_LengthA1+hv_Width, 
            50);
        GenRectangle2(&ho_RectangleA1, hv_RowA, hv_ColumnA, hv_PhiA, hv_LengthA1+hv_Width, 
            1);
      }
      else
      {
        GenRectangle2(&ho_Rectangle1, hv_RowA, hv_ColumnA, hv_PhiA, 50, hv_LengthA2+hv_Width);
        GenRectangle2(&ho_RectangleA1, hv_RowA, hv_ColumnA, hv_PhiA, 1, hv_LengthA2+hv_Width);
      }
      DistanceRrMin(ho_RegionCentrePoint, ho_RectangleA1, &hv_MinDistance, &hv_Row11, 
          &hv_Column11, &hv_soldereddotRowA, &hv_soldereddotColumnA);
      Difference(ho_ConnectedRegions3, ho_Rectangle1, &ho_RegionDifference);
      SelectShapeStd(ho_RegionDifference, &ho_SelectedRegionsB, "max_area", 100);
      SmallestRectangle2(ho_SelectedRegionsB, &hv_RowB, &hv_ColumnB, &hv_PhiB, &hv_LengthB1, 
          &hv_LengthB2);
      if (0 != (hv_LengthB1>hv_LengthB2))
      {
        GenRectangle2(&ho_RectangleB1, hv_RowB, hv_ColumnB, hv_PhiB, hv_LengthB1+hv_Width, 
            1);
      }
      else
      {
        GenRectangle2(&ho_RectangleB1, hv_RowB, hv_ColumnB, hv_PhiB, 1, hv_LengthB2+hv_Width);
      }
      DistanceRrMin(ho_RegionCentrePoint, ho_RectangleB1, &hv_MinDistance, &hv_Row11, 
          &hv_Column11, &hv_soldereddotRowB, &hv_soldereddotColumnB);


      Union2(ho_RectangleA1, ho_RectangleB1, &ho_RegionUnion);

      DilationCircle(ho_RegionUnion, &ho_RegionDilation4, 50);
      Difference(ho_RegionDifference1, ho_RegionDilation4, &ho_RegionDifference2);
      Union1(ho_RegionDifference2, &ho_RegionUnion1);
      AreaCenter(ho_RegionUnion1, &hv_Area2, &hv_Row2, &hv_Column2);
      if (0 != (HTuple((hv_Area2.TupleLength())==0).TupleOr(HTuple(hv_Area2[0])==0)))
      {
        (*hv_ResultInfo) = "无焊点";
        return;
      }
      AngleLl(0, 0, 100, 0, hv_soldereddotRowA, hv_soldereddotColumnA, hv_RowA, hv_ColumnA, 
          &hv_AngleA);
      AngleLl(0, 0, 100, 0, hv_soldereddotRowB, hv_soldereddotColumnB, hv_RowB, hv_ColumnB, 
          &hv_AngleB);
      AngleLl(hv_soldereddotRowA, hv_soldereddotColumnA, hv_RowA, hv_ColumnA, hv_soldereddotRowB, 
          hv_soldereddotColumnB, hv_RowB, hv_ColumnB, &hv_AngleAB);
      if (0 != (hv_AngleA<0))
      {
        hv_degAngleA = -(hv_AngleA.TupleDeg());
      }
      else
      {
        hv_degAngleA = 360-(hv_AngleA.TupleDeg());
      }
      if (0 != (hv_AngleB<0))
      {
        hv_degAngleB = -(hv_AngleB.TupleDeg());
      }
      else
      {
        hv_degAngleB = 360-(hv_AngleB.TupleDeg());
      }
      hv_degAngleAB = (hv_AngleAB.TupleDeg()).TupleAbs();
      (*hv_WindowInfo) = (*hv_WindowInfo).TupleConcat((((("针脚夹角差:"+hv_degAngleAB)+",")+hv_degAngleA)+",")+hv_degAngleB);

      if (0 != hv_ShowHide)
      {
        DispCross(hv_WindowHandle, hv_RowA.TupleConcat(hv_RowB), hv_ColumnA.TupleConcat(hv_ColumnB), 
            56, HTuple(45).TupleRad());
      }
      DistancePr(ho_RegionUnion1, hv_soldereddotRowA, hv_soldereddotColumnA, &hv_DistanceMinA, 
          &hv_DistanceMaxA);
      DistancePr(ho_RegionUnion1, hv_soldereddotRowB, hv_soldereddotColumnB, &hv_DistanceMinB, 
          &hv_DistanceMaxB);
      if (0 != (hv_DistanceMinA>hv_DistanceMinB))
      {
        hv_soldereddotRow = hv_soldereddotRowA;
        hv_soldereddotColumn = hv_soldereddotColumnA;
        hv_soldereddotRowA = hv_soldereddotRowB;
        hv_soldereddotColumnA = hv_soldereddotColumnB;
        hv_soldereddotRowB = hv_soldereddotRow;
        hv_soldereddotColumnB = hv_soldereddotColumn;
      }

    }
    else
    {
      DilationCircle(ho_SelectedRegionsA, &ho_RegionErosion3, 120);
      Difference(ho_ConnectedRegions3, ho_RegionErosion3, &ho_RegionDifference3);
      Connection(ho_RegionDifference3, &ho_ConnectedRegions6);
      SelectShapeStd(ho_ConnectedRegions6, &ho_SelectedRegionsB, "max_area", 100);
      AreaCenter(ho_SelectedRegionsA, &hv_AreaA, &hv_soldereddotRowA, &hv_soldereddotColumnA);
      AreaCenter(ho_SelectedRegionsB, &hv_AreaB, &hv_soldereddotRowB, &hv_soldereddotColumnB);
      if (0 != (HTuple((hv_soldereddotRowA.TupleLength())>0).TupleAnd((hv_soldereddotRowB.TupleLength())>0)))
      {
        Union1(ho_RegionDifference1, &ho_RegionUnion1);
        DistancePr(ho_RegionUnion1, hv_soldereddotRowA, hv_soldereddotColumnA, &hv_DistanceMinA, 
            &hv_DistanceMaxA);
        DistancePr(ho_RegionUnion1, hv_soldereddotRowB, hv_soldereddotColumnB, &hv_DistanceMinB, 
            &hv_DistanceMaxB);
        if (0 != (hv_DistanceMinA>hv_DistanceMinB))
        {
          hv_soldereddotRow = hv_soldereddotRowA;
          hv_soldereddotColumn = hv_soldereddotColumnA;
          hv_soldereddotRowA = hv_soldereddotRowB;
          hv_soldereddotColumnA = hv_soldereddotColumnB;
          hv_soldereddotRowB = hv_soldereddotRow;
          hv_soldereddotColumnB = hv_soldereddotColumn;
        }
      }
    }
  }


  if (0 != (HTuple((hv_soldereddotRowA.TupleLength())>0).TupleAnd((hv_soldereddotRowB.TupleLength())>0)))
  {
    if (0 != (HTuple(HTuple(hv_soldereddotRowA[0])!=HTuple(hv_soldereddotRowB[0])).TupleOr(HTuple(hv_soldereddotColumnA[0])!=HTuple(hv_soldereddotColumnB[0]))))
    {

      AngleLl(hv_Row, hv_Column, hv_soldereddotRowA, hv_soldereddotColumnA, hv_Row, 
          hv_Column, hv_soldereddotRowB, hv_soldereddotColumnB, &hv_dotAngle);
      hv_degdotAngle = (((((hv_dotAngle.TupleDeg()).TupleInt())%180).TupleAbs())-180).TupleAbs();


      if (0 != hv_ShowHide)
      {
        DispCross(hv_WindowHandle, HTuple(hv_soldereddotRowA[0]).TupleConcat(HTuple(hv_soldereddotRowB[0])), 
            HTuple(hv_soldereddotColumnA[0]).TupleConcat(HTuple(hv_soldereddotColumnB[0])), 
            56, HTuple(45).TupleRad());

      }
      (*hv_WindowInfo) = (*hv_WindowInfo).TupleConcat("导针夹角:"+hv_degdotAngle);
      if (0 != (hv_degdotAngle>30))
      {
        (*hv_ResultInfo) = "导针夹角异常";
        return;
      }

      if (0 != (hv_degAngleA>=0))
      {
        hv_Angle = hv_degAngleA;
      }
      else
      {
        AngleLl(hv_soldereddotRowA, hv_soldereddotColumnA, hv_soldereddotRowA, hv_soldereddotColumnA-200, 
            hv_soldereddotRowA, hv_soldereddotColumnA, hv_soldereddotRowB, hv_soldereddotColumnB, 
            &hv_soldereddotAngle);
        if (0 != (hv_soldereddotAngle<0))
        {
          hv_Angle = -(hv_soldereddotAngle.TupleDeg());
        }
        else
        {
          hv_Angle = 360-(hv_soldereddotAngle.TupleDeg());
        }
      }
      hv_Angle = (hv_Angle*100).TupleInt();
      //outVectorInfos.insert(outVectorInfos.length(),['角度',Angle])
      (*hv_WindowInfo) = (*hv_WindowInfo).TupleConcat("导针角度:"+hv_Angle);
      SetMessageTuple(hv_MessageHandle, "Result_Angle", hv_Angle);
      //outVectorInfos.insert(outVectorInfos.length(),['焊点坐标',soldereddotRowA, soldereddotColumnA,soldereddotRowB, soldereddotColumnB])
      (*hv_WindowInfo) = (*hv_WindowInfo).TupleConcat(((((((("焊点坐标["+hv_soldereddotRowA)+",")+hv_soldereddotColumnA)+",")+hv_soldereddotRowB)+",")+hv_soldereddotColumnB)+"]");

      hv_ImageInfoval.Clear();
      hv_ImageInfoval.Append(hv_soldereddotRowA);
      hv_ImageInfoval.Append(hv_soldereddotColumnA);
      hv_ImageInfoval.Append(hv_soldereddotRowB);
      hv_ImageInfoval.Append(hv_soldereddotColumnB);
      Py_Memory_Check(ho_Image, &ho_ImageResult, hv_MessageHandle, hv_WindowHandle, 
          hv_ShowHide, hv_Width, hv_Height, hv_ImageInfoval, &hv_PyResultVal);
      GetPyFeature(ho_ImageResult, hv_MessageHandle, hv_ShowHide, hv_WindowHandle, 
          hv_PyResultVal, &hv_PyResultInfo, &hv_PyWindowInfo, &hvec_PyFeatureVals);
      (*hv_ResultInfo) = hv_PyResultInfo;
      (*hv_WindowInfo) = (*hv_WindowInfo).TupleConcat(hv_PyWindowInfo);
      (*hvec_FeatureVals) = hvec_PyFeatureVals;

    }
    else
    {
      (*hv_ResultInfo) = "无焊点";
    }

  }
  else
  {
    (*hv_ResultInfo) = "无焊点";
  }

  return;
}

void load_config_set_message_Str (HTuple hv_MessageHandle, HTuple hv_ParamSettingsFile, 
    HTuple hv_section, HTuple hv_Inikey, HTuple hv_MessageKey, HTuple hv_Defaultval, 
    HTuple *hv_val)
{

  load_config(hv_ParamSettingsFile, hv_section, hv_Inikey, hv_Defaultval, &(*hv_val));
  SetMessageTuple(hv_MessageHandle, hv_MessageKey, (*hv_val));
  //
  //
  return;
}

void OCR_Find (HObject ho_ImageReduced, HObject ho_Image, HTuple hv_ShowHide, HTuple hv_WindowHandle, 
    HTuple hv_MessageHandle, HTuple hv_OCRSign, HTuple hv_Width, HTuple hv_Height, 
    HTuple *hv_isFindOCR, HTuple *hv_WindowInfo)
{

  // Local iconic variables
  HObject  ho_DupImage333, ho_DupImage222, ho_ModelContours;
  HObject  ho_TransContours, ho_Region, ho_RegionUnion, ho_Rectangle2;
  HObject  ho_ImageReduced1, ho_ImagePart, ho_ImageRotate1;
  HObject  ho_ContoursAffinTrans, ho_Retangle1, ho_Rectangle1;
  HObject  ho_Rectangle, ho_ImageRotate, ho_RegionAffineTrans;

  // Local control variables
  HTuple  hv_OCRVal, hv_shmdfm, hv_ModelId, hv_ResultHomMat;
  HTuple  hv_ModelScore, hv_lenOCRSignstr, hv_lenOCRValstr;
  HTuple  hv_MatchingObjIdx, hv__TempHomMat2D, hv_OCRDirection;
  HTuple  hv_Row11, hv_Column11, hv_Row22, hv_Column22, hv_OcrHandle;
  HTuple  hv_TextModel, hv_L, hv_h, hv_LL, hv_OCRChrs, hv_OCRChrsConfidences;
  HTuple  hv_ocrstr, hv_ModelRow, hv_ModelColumn, hv_ModelAngle;
  HTuple  hv_shmps, hv_Index2, hv_HomMat, hv_degModelAngle;
  HTuple  hv_degModelAngle1, hv_Lesseq, hv_Indices, hv_ResultInfo;
  HTuple  hv_degAngle, hv_Row1, hv_Column1, hv_Row21, hv_Column21;
  HTuple  hv_w, hv_RowTrans1, hv_ColTrans1, hv_Area, hv_Row;
  HTuple  hv_Column, hv_Area2, hv_Row2, hv_Column2, hv_HomMat2DIdentity;
  HTuple  hv_HomMat2DRotate, hv_HomMat2DTranslate, hv_ocrstruF;
  HTuple  hv_OCRResultUse;


  (*hv_WindowInfo) = HTuple();
  GetMessageTuple(hv_MessageHandle, hv_OCRSign+"_val", &hv_OCRVal);
  GetMessageTuple(hv_MessageHandle, hv_OCRSign+"_shmdfm", &hv_shmdfm);

  CopyImage(ho_ImageReduced, &ho_DupImage333);
  CopyImage(ho_Image, &ho_DupImage222);
  (*hv_isFindOCR) = 0;
  if (0 != (hv_shmdfm==HTuple("dfm")))
  {

    GetMessageTuple(hv_MessageHandle, hv_OCRSign+"_dfmModelId", &hv_ModelId);
    GetDeformableModelContours(&ho_ModelContours, hv_ModelId, 1);

    FindPlanarUncalibDeformableModel(ho_ImageReduced, hv_ModelId, HTuple(0).TupleRad(), 
        HTuple(360).TupleRad(), 1, 1, 1, 1, 0.5, 10, 0.5, 4, 0.75, HTuple(), HTuple(), 
        &hv_ResultHomMat, &hv_ModelScore);

    //find_planar_uncalib_deformable_model (ImageReduced, ModelId, rad(0), rad(360), 1, 1, 1, 1, 0.5, 10, 0.5, 4, 0.75, ['subpixel'], ['least_squares_very_high'], ResultHomMat, ModelScore)

    TupleStrlen(hv_OCRSign, &hv_lenOCRSignstr);
    TupleStrlen(hv_OCRVal, &hv_lenOCRValstr);
    //Matching 02: transform the model contours into the detected positions
    {
    HTuple end_val20 = (hv_ModelScore.TupleLength())-1;
    HTuple step_val20 = 1;
    for (hv_MatchingObjIdx=0; hv_MatchingObjIdx.Continue(end_val20, step_val20); hv_MatchingObjIdx += step_val20)
    {
      hv__TempHomMat2D = hv_ResultHomMat.TupleSelectRange(hv_MatchingObjIdx*9,(hv_MatchingObjIdx*9)+8);
      ProjectiveTransContourXld(ho_ModelContours, &ho_TransContours, hv__TempHomMat2D);
      GenRegionContourXld(ho_TransContours, &ho_Region, "filled");
      GetMessageTuple(hv_MessageHandle, hv_OCRSign+"_Direction", &hv_OCRDirection);
      Union1(ho_Region, &ho_RegionUnion);
      SmallestRectangle1(ho_RegionUnion, &hv_Row11, &hv_Column11, &hv_Row22, &hv_Column22);
      GetMessageTuple(hv_MessageHandle, hv_OCRSign+"OcrHandle", &hv_OcrHandle);
      GetMessageTuple(hv_MessageHandle, hv_OCRSign+"TextModel", &hv_TextModel);
      if (0 != (hv_OCRDirection==0))
      {
        hv_L = hv_Column22-hv_Column11;
        hv_h = hv_Row22-hv_Row11;
        hv_LL = (hv_L/hv_lenOCRSignstr)+12;
        GenRectangle1(&ho_Rectangle2, hv_Row11-5, hv_Column11-(hv_lenOCRValstr*hv_LL), 
            hv_Row22+5, hv_Column22+5);
        //Show_Hide (Rectangle2, 1, WindowHandle)
        ReduceDomain(ho_Image, ho_Rectangle2, &ho_ImageReduced1);
        CropDomain(ho_ImageReduced1, &ho_ImagePart);
        GetImageSize(ho_ImagePart, &hv_Width, &hv_Height);
        GenRectangle1(&ho_Rectangle2, 0, 0, hv_Height, hv_Width);
        GetOCRChrs(ho_ImagePart, ho_Rectangle2, hv_TextModel, hv_OcrHandle, &hv_OCRChrs, 
            &hv_OCRChrsConfidences);
      }
      else if (0 != (hv_OCRDirection==90))
      {
        hv_h = hv_Column22-hv_Column11;
        hv_L = hv_Row22-hv_Row11;
        hv_LL = (hv_L/hv_lenOCRSignstr)+12;
        GenRectangle1(&ho_Rectangle2, hv_Row11, hv_Column11-5, hv_Row22+(hv_lenOCRValstr*hv_LL), 
            hv_Column22+5);
        //Show_Hide (Rectangle2, 1, WindowHandle)
        ReduceDomain(ho_Image, ho_Rectangle2, &ho_ImageReduced1);
        CropDomain(ho_ImageReduced1, &ho_ImagePart);
        RotateImage(ho_ImagePart, &ho_ImageRotate1, -90, "constant");
        GetImageSize(ho_ImageRotate1, &hv_Width, &hv_Height);
        GenRectangle1(&ho_Rectangle2, 0, 0, hv_Height, hv_Width);
        GetOCRChrs(ho_ImageRotate1, ho_Rectangle2, hv_TextModel, hv_OcrHandle, &hv_OCRChrs, 
            &hv_OCRChrsConfidences);

      }
      else if (0 != (hv_OCRDirection==180))
      {

        hv_L = hv_Column22-hv_Column11;
        hv_h = hv_Row22-hv_Row11;
        hv_LL = (hv_L/hv_lenOCRSignstr)+12;
        GenRectangle1(&ho_Rectangle2, hv_Row11-5, hv_Column11, hv_Row22+5, hv_Column22+(hv_lenOCRValstr*hv_LL));
        //Show_Hide (Rectangle2, 1, WindowHandle)
        ReduceDomain(ho_Image, ho_Rectangle2, &ho_ImageReduced1);
        CropDomain(ho_ImageReduced1, &ho_ImagePart);
        RotateImage(ho_ImagePart, &ho_ImageRotate1, -180, "constant");
        GetImageSize(ho_ImageRotate1, &hv_Width, &hv_Height);
        GenRectangle1(&ho_Rectangle2, 0, 0, hv_Height, hv_Width);
        GetOCRChrs(ho_ImageRotate1, ho_Rectangle2, hv_TextModel, hv_OcrHandle, &hv_OCRChrs, 
            &hv_OCRChrsConfidences);

      }
      else if (0 != (hv_OCRDirection==270))
      {
        hv_h = hv_Column22-hv_Column11;
        hv_L = hv_Row22-hv_Row11;
        hv_LL = (hv_L/hv_lenOCRSignstr)+12;
        GenRectangle1(&ho_Rectangle2, hv_Row11-(hv_lenOCRValstr*hv_LL), hv_Column11-5, 
            hv_Row22+5, hv_Column22+5);
        //Show_Hide (Rectangle2, 1, WindowHandle)
        ReduceDomain(ho_Image, ho_Rectangle2, &ho_ImageReduced1);
        CropDomain(ho_ImageReduced1, &ho_ImagePart);
        RotateImage(ho_ImagePart, &ho_ImageRotate1, -270, "constant");
        GetImageSize(ho_ImageRotate1, &hv_Width, &hv_Height);
        GenRectangle1(&ho_Rectangle2, 0, 0, hv_Height, hv_Width);
        GetOCRChrs(ho_ImageRotate1, ho_Rectangle2, hv_TextModel, hv_OcrHandle, &hv_OCRChrs, 
            &hv_OCRChrsConfidences);
      }
      if (0 != ((hv_OCRChrs.TupleLength())>=(hv_OCRVal.TupleStrlen())))
      {
        hv_ocrstr = (hv_OCRChrs.TupleSelectRange(0,(hv_OCRVal.TupleStrlen())-1)).TupleSum();
        TupleString(hv_ocrstr, "#", &hv_ocrstr);
        if (0 != (hv_ocrstr==hv_OCRVal))
        {
          (*hv_isFindOCR) = 1;
          break;
        }
      }
    }
    }



  }
  else if (0 != (hv_shmdfm==HTuple("shm")))
  {

    GetMessageTuple(hv_MessageHandle, hv_OCRSign+"_shmModelId", &hv_ModelId);
    FindShapeModel(ho_ImageReduced, hv_ModelId, HTuple(0).TupleRad(), HTuple(360).TupleRad(), 
        0.3, 10, 0.5, "least_squares", (HTuple(5).Append(1)), 0.75, &hv_ModelRow, 
        &hv_ModelColumn, &hv_ModelAngle, &hv_ModelScore);
    GetShapeModelContours(&ho_ModelContours, hv_ModelId, 1);
    GetMessageTuple(hv_MessageHandle, hv_OCRSign+"_shmps", &hv_shmps);
    {
    HTuple end_val98 = (hv_ModelAngle.TupleLength())-1;
    HTuple step_val98 = 1;
    for (hv_Index2=0; hv_Index2.Continue(end_val98, step_val98); hv_Index2 += step_val98)
    {
      HomMat2dIdentity(&hv_HomMat);
      HomMat2dRotate(hv_HomMat, HTuple(hv_ModelAngle[hv_Index2]), 0, 0, &hv_HomMat);
      HomMat2dTranslate(hv_HomMat, HTuple(hv_ModelRow[hv_Index2]), HTuple(hv_ModelColumn[hv_Index2]), 
          &hv_HomMat);
      AffineTransContourXld(ho_ModelContours, &ho_ContoursAffinTrans, hv_HomMat);
      GenRegionContourXld(ho_ContoursAffinTrans, &ho_Region, "filled");
    }
    }
    hv_degModelAngle = (hv_ModelAngle.TupleDeg()).TupleInt();
    hv_degModelAngle1 = hv_degModelAngle%90;
    TupleLessEqualElem(hv_degModelAngle1.TupleAbs(), 8, &hv_Lesseq);
    TupleFind(hv_Lesseq, 1, &hv_Indices);
    if (0 != ((hv_Indices.TupleLength())==0))
    {
      hv_ResultInfo = "空料";
      (*hv_WindowInfo) = (*hv_WindowInfo).TupleConcat(hv_OCRSign+"无法识别");
      return;
    }
    if (0 != (HTuple(hv_Indices[0])<0))
    {
      hv_ResultInfo = "空料";
      (*hv_WindowInfo) = (*hv_WindowInfo).TupleConcat(hv_OCRSign+"无法识别");
      return;
    }
    hv_degModelAngle = ((const HTuple&)hv_degModelAngle)[hv_Indices];
    hv_ModelRow = ((const HTuple&)hv_ModelRow)[hv_Indices];
    hv_ModelColumn = ((const HTuple&)hv_ModelColumn)[hv_Indices];
    hv_ModelScore = ((const HTuple&)hv_ModelScore)[hv_Indices];
    hv_ModelAngle = ((const HTuple&)hv_ModelAngle)[hv_Indices];

    hv_degModelAngle = (hv_ModelAngle.TupleDeg())+180;
    {
    HTuple end_val126 = (hv_degModelAngle.TupleLength())-1;
    HTuple step_val126 = 1;
    for (hv_Index2=0; hv_Index2.Continue(end_val126, step_val126); hv_Index2 += step_val126)
    {
      hv_degAngle = ((const HTuple&)hv_degModelAngle)[hv_Index2];
      if (0 != (hv_degAngle!=-1))
      {
        HomMat2dIdentity(&hv_HomMat);
        HomMat2dRotate(hv_HomMat, HTuple(hv_ModelAngle[hv_Index2]), 0, 0, &hv_HomMat);
        HomMat2dTranslate(hv_HomMat, HTuple(hv_ModelRow[hv_Index2]), HTuple(hv_ModelColumn[hv_Index2]), 
            &hv_HomMat);
        AffineTransContourXld(ho_ModelContours, &ho_ContoursAffinTrans, hv_HomMat);
        GenRegionContourXld(ho_ContoursAffinTrans, &ho_Region, "filled");
        Union1(ho_Region, &ho_RegionUnion);
        SmallestRectangle1(ho_RegionUnion, &hv_Row1, &hv_Column1, &hv_Row21, &hv_Column21);
        GetMessageTuple(hv_MessageHandle, hv_OCRSign+"_Direction", &hv_OCRDirection);
        //get_message_tuple (MessageHandle, 'OCRuFRectval', OCRuFRectval)
        if (0 != (hv_OCRDirection==0))
        {
          hv_w = (1.0*(hv_Column21-hv_Column1))/2;
          hv_h = hv_Row21-hv_Row1;
          GenRectangle1(&ho_Retangle1, hv_Row1-10, hv_Column1-(3*hv_w), hv_Row21+10, 
              hv_Column1);

          GenRectangle1(&ho_Rectangle1, (((1.0*(hv_Row1+hv_Row21))/2)-((1.0*hv_h)/2))-3, 
              (hv_Column1-hv_w)-3, (((1.0*(hv_Row1+hv_Row21))/2)+((1.0*hv_h)/2))+3, 
              hv_Column1-2);
        }




        AffineTransPixel(hv_HomMat, HTuple(hv_shmps[0]).TupleConcat(HTuple(hv_shmps[2])), 
            HTuple(hv_shmps[1]).TupleConcat(HTuple(hv_shmps[3])), &hv_RowTrans1, 
            &hv_ColTrans1);
        if (0 != (HTuple(HTuple(hv_RowTrans1[0])<HTuple(hv_RowTrans1[1])).TupleAnd(HTuple(hv_ColTrans1[0])<HTuple(hv_ColTrans1[1]))))
        {
          GenRectangle1(&ho_Rectangle, HTuple(hv_RowTrans1[0]), HTuple(hv_ColTrans1[0]), 
              HTuple(hv_RowTrans1[1]), HTuple(hv_ColTrans1[1]));
        }
        else if (0 != (HTuple(HTuple(hv_RowTrans1[0])<HTuple(hv_RowTrans1[1])).TupleAnd(HTuple(hv_ColTrans1[0])>HTuple(hv_ColTrans1[1]))))
        {
          GenRectangle1(&ho_Rectangle, HTuple(hv_RowTrans1[0]), HTuple(hv_ColTrans1[1]), 
              HTuple(hv_RowTrans1[1]), HTuple(hv_ColTrans1[0]));
          hv_degAngle += 180;
        }
        else if (0 != (HTuple(HTuple(hv_RowTrans1[0])>HTuple(hv_RowTrans1[1])).TupleAnd(HTuple(hv_ColTrans1[0])<HTuple(hv_ColTrans1[1]))))
        {
          GenRectangle1(&ho_Rectangle, HTuple(hv_RowTrans1[1]), HTuple(hv_ColTrans1[0]), 
              HTuple(hv_RowTrans1[0]), HTuple(hv_ColTrans1[1]));
          hv_degAngle += 180;
        }
        else if (0 != (HTuple(HTuple(hv_RowTrans1[0])>HTuple(hv_RowTrans1[1])).TupleAnd(HTuple(hv_ColTrans1[0])>HTuple(hv_ColTrans1[1]))))
        {
          GenRectangle1(&ho_Rectangle, HTuple(hv_RowTrans1[1]), HTuple(hv_ColTrans1[1]), 
              HTuple(hv_RowTrans1[0]), HTuple(hv_ColTrans1[0]));
        }
        AreaCenter(ho_Image, &hv_Area, &hv_Row, &hv_Column);
        RotateImage(ho_Image, &ho_ImageRotate, hv_degAngle+180, "constant");
        AreaCenter(ho_ImageRotate, &hv_Area2, &hv_Row2, &hv_Column2);
        HomMat2dIdentity(&hv_HomMat2DIdentity);
        HomMat2dRotate(hv_HomMat2DIdentity, (hv_degAngle+180).TupleRad(), hv_Row, 
            hv_Column, &hv_HomMat2DRotate);
        HomMat2dTranslate(hv_HomMat2DRotate, hv_Row2-hv_Row, hv_Column2-hv_Column, 
            &hv_HomMat2DTranslate);
        AffineTransRegion(ho_Rectangle, &ho_RegionAffineTrans, hv_HomMat2DTranslate, 
            "constant");
        GetMessageTuple(hv_MessageHandle, hv_OCRSign+"OcrHandle", &hv_OcrHandle);
        GetMessageTuple(hv_MessageHandle, hv_OCRSign+"TextModel", &hv_TextModel);
        GetOCRChrs(ho_ImageRotate, ho_RegionAffineTrans, hv_TextModel, hv_OcrHandle, 
            &hv_OCRChrs, &hv_OCRChrsConfidences);
        if (0 != ((hv_OCRChrs.TupleLength())>=(hv_OCRVal.TupleStrlen())))
        {
          hv_ocrstruF = (hv_OCRChrs.TupleSelectRange(0,(hv_OCRVal.TupleStrlen())-1)).TupleSum();
          TupleString(hv_ocrstruF, "#", &hv_ocrstruF);
          if (0 != (hv_ocrstruF==hv_OCRVal))
          {
            (*hv_isFindOCR) = 1;
            break;
          }
        }
      }
    }
    }



  }
  GetMessageTuple(hv_MessageHandle, hv_OCRSign+"_ResultUse", &hv_OCRResultUse);
  if (0 != (*hv_isFindOCR))
  {
    (*hv_WindowInfo) = (*hv_WindowInfo).TupleConcat((((hv_OCRSign+"[")+hv_OCRVal)+"]")+"被识别");
  }
  else
  {
    (*hv_WindowInfo) = (*hv_WindowInfo).TupleConcat((((hv_OCRSign+"[")+hv_OCRVal)+"]")+"未识别");
  }
  if (0 != (hv_OCRResultUse!=1))
  {
    (*hv_isFindOCR) = 1;
    (*hv_WindowInfo) = (*hv_WindowInfo).TupleConcat((((hv_OCRSign+"[")+hv_OCRVal)+"]")+"结果禁用");
  }






  return;
}

void GetOCRChrs (HObject ho_TmpObj_Mono, HObject ho_ROI_OCR_uF, HTuple hv_TextModel, 
    HTuple hv_OcrHandle, HTuple *hv_OCRChrs, HTuple *hv_OCRChrsConfidences)
{

  // Local iconic variables
  HObject  ho_TmpObj_MonoReduced_OCR_02_0, ho_TmpObj_Domain;
  HObject  ho_TmpObj_DomainExpanded, ho_TmpObj_DomainTransformedRaw;
  HObject  ho_TmpObj_DomainTransformed, ho_TmpObj_ImageTransformed;
  HObject  ho_TmpObj_ImageTransformedExpanded, ho_TmpObj_ImageTransformedReduced;
  HObject  ho_TmpObj_MonoInverted_OCR_02_0, ho_Symbols_OCR_02_0;

  // Local control variables
  HTuple  hv_TmpCtrl_MatrixIdentity, hv_TmpCtrl_ClipRegion;
  HTuple  hv_TmpCtrl_Row1, hv_TmpCtrl_Col1, hv_TmpCtrl_Row2;
  HTuple  hv_TmpCtrl_Col2, hv_TmpCtrl_MatrixTranslation, hv_TmpCtrl_MatrixComposite;
  HTuple  hv_TmpCtrl_ResultHandle_OCR_02_0, hv_SymbolNames_OCR_02_0;
  HTuple  hv_Confidences_OCR_02_0;

  ReduceDomain(ho_TmpObj_Mono, ho_ROI_OCR_uF, &ho_TmpObj_MonoReduced_OCR_02_0);
  HomMat2dIdentity(&hv_TmpCtrl_MatrixIdentity);
  GetDomain(ho_TmpObj_MonoReduced_OCR_02_0, &ho_TmpObj_Domain);
  GetSystem("clip_region", &hv_TmpCtrl_ClipRegion);
  SetSystem("clip_region", "false");
  DilationCircle(ho_TmpObj_Domain, &ho_TmpObj_DomainExpanded, 45);
  AffineTransRegion(ho_TmpObj_DomainExpanded, &ho_TmpObj_DomainTransformedRaw, hv_TmpCtrl_MatrixIdentity, 
      "true");
  SmallestRectangle1(ho_TmpObj_DomainTransformedRaw, &hv_TmpCtrl_Row1, &hv_TmpCtrl_Col1, 
      &hv_TmpCtrl_Row2, &hv_TmpCtrl_Col2);
  HomMat2dTranslate(hv_TmpCtrl_MatrixIdentity, -hv_TmpCtrl_Row1, -hv_TmpCtrl_Col1, 
      &hv_TmpCtrl_MatrixTranslation);
  HomMat2dCompose(hv_TmpCtrl_MatrixTranslation, hv_TmpCtrl_MatrixIdentity, &hv_TmpCtrl_MatrixComposite);
  AffineTransRegion(ho_TmpObj_Domain, &ho_TmpObj_DomainTransformed, hv_TmpCtrl_MatrixComposite, 
      "true");
  AffineTransImage(ho_TmpObj_MonoReduced_OCR_02_0, &ho_TmpObj_ImageTransformed, hv_TmpCtrl_MatrixComposite, 
      "constant", "true");
  //
  DilationCircle(ho_TmpObj_Domain, &ho_TmpObj_DomainExpanded, 45);
  ExpandDomainGray(ho_TmpObj_ImageTransformed, &ho_TmpObj_ImageTransformedExpanded, 
      45);
  ReduceDomain(ho_TmpObj_ImageTransformed, ho_TmpObj_DomainTransformed, &ho_TmpObj_ImageTransformedReduced
      );
  CropPart(ho_TmpObj_ImageTransformedReduced, &ho_TmpObj_MonoReduced_OCR_02_0, 0, 
      0, (hv_TmpCtrl_Col2-hv_TmpCtrl_Col1)+1, (hv_TmpCtrl_Row2-hv_TmpCtrl_Row1)+1);
  SetSystem("clip_region", hv_TmpCtrl_ClipRegion);
  FindText(ho_TmpObj_MonoReduced_OCR_02_0, hv_TextModel, &hv_TmpCtrl_ResultHandle_OCR_02_0);
  InvertImage(ho_TmpObj_MonoReduced_OCR_02_0, &ho_TmpObj_MonoInverted_OCR_02_0);
  GetTextObject(&ho_Symbols_OCR_02_0, hv_TmpCtrl_ResultHandle_OCR_02_0, "all_lines");
  ClearTextResult(hv_TmpCtrl_ResultHandle_OCR_02_0);
  DoOcrMultiClassMlp(ho_Symbols_OCR_02_0, ho_TmpObj_MonoInverted_OCR_02_0, hv_OcrHandle, 
      &hv_SymbolNames_OCR_02_0, &hv_Confidences_OCR_02_0);
  (*hv_OCRChrs) = hv_SymbolNames_OCR_02_0;
  (*hv_OCRChrsConfidences) = hv_Confidences_OCR_02_0;
  return;
}

void load_config_split (HTuple hv_inifile, HTuple hv_Section, HTuple hv_keyname, 
    HTuple hv_defaultval, HTuple hv_splitstr, HTuple *hv_val)
{

  load_config(hv_inifile, hv_Section, hv_keyname, hv_defaultval, &(*hv_val));
  TupleSplit((*hv_val), hv_splitstr, &(*hv_val));
  TupleString((*hv_val), "#", &(*hv_val));
  return;
}

void load_config_split_numeber (HTuple hv_inifile, HTuple hv_Section, HTuple hv_keyname, 
    HTuple hv_defaultval, HTuple hv_splitstr, HTuple *hv_val)
{

  load_config_split(hv_inifile, hv_Section, hv_keyname, hv_defaultval, hv_splitstr, 
      &(*hv_val));
  TupleNumber((*hv_val), &(*hv_val));
  return;
}

void MainTest (HTuple hv_TestName, HTuple hv_IsTain, HTuple hv_ImageW, HTuple hv_ImageH, 
    HTuple hv_CameraIndex, HTuple hv_ImagePath)
{

  // Local iconic variables
  HObject  ho_Objects, ho_ObjectData, ho_Image;
  HObject  ho_PreprocessImage, ho_Image1, ho_PreprocessImage2;

  // Local control variables
  HTuple  hv_WindowHandle, hv_MessageHandle1, hv_MessageHandle;
  HTuple  hv_Seconds1, hv_Seconds2, hv_sss, hv_GenParamNames;
  HTuple  hv_Index, hv_GenParamType, hv_TupleData1, hv_ImageFiles;
  HTuple  hv_FileHandle, hv_IndexSN, hv_ResultInfo, hv_outLogInfo;
  HTuple  hv_Exception, hv_str, hv_DrawIDs, hv_Params, hv_DrawID;
  HTuple  hv_ParamType, hv_Paramstr, hv_ParamNote, hv_ParamData;
  HTuple  hv_Resultstrs, hv_ResultName, hv_Resultstrs2, hv_TupleData;
  HTuple  hv_Format, hv_fillcolor, hv_filename;
  HTupleVector  hvec_vGenParamNameVals(1), hvec_sssssssssss(2);
  HTupleVector  hvec_FeatureValss(2), hvec_adsa(1), hvec_FeatureValss1(2);

  //
  //* global def tuple TestImagePath
  //
  if (HDevWindowStack::IsOpen())
    CloseWindow(HDevWindowStack::Pop());
  SetWindowAttr("background_color","black");
  OpenWindow(0,0,800,800,0,"","",&hv_WindowHandle);
  HDevWindowStack::Push(hv_WindowHandle);
  //
  CreateMessage(&hv_MessageHandle1);
  InitGlobalOnce();

  ResetObjDb(5000, 5000, 0);
  //初始化
  InitCheck(hv_TestName, hv_CameraIndex, hv_ImageW, hv_ImageH, &hv_MessageHandle);
  CountSeconds(&hv_Seconds1);
  getallmessage(hv_MessageHandle);
  CountSeconds(&hv_Seconds2);
  hv_sss = hv_Seconds2-hv_Seconds1;
  //
  hvec_vGenParamNameVals = (HTupleVector(1).Insert(0,HTupleVector(HTuple())));
  hvec_vGenParamNameVals.Clear();
  if (HDevWindowStack::IsOpen())
    SetDraw(HDevWindowStack::GetActive(),"margin");
  GenEmptyObj(&ho_Objects);
  GetMessageParam(hv_MessageHandle, "message_keys", HTuple(), &hv_GenParamNames);
  {
  HTuple end_val22 = (hv_GenParamNames.TupleLength())-1;
  HTuple step_val22 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val22, step_val22); hv_Index += step_val22)
  {
    GetMessageParam(hv_MessageHandle, "key_data_type", HTuple(hv_GenParamNames[hv_Index]), 
        &hv_GenParamType);
    if (0 != (hv_GenParamType==HTuple("tuple")))
    {
      GetMessageTuple(hv_MessageHandle, HTuple(hv_GenParamNames[hv_Index]), &hv_TupleData1);
      hvec_vGenParamNameVals.Insert(hvec_vGenParamNameVals.Length(),HTupleVector(HTuple(HTuple(hv_GenParamNames[hv_Index]).TupleConcat(hv_TupleData1))));
    }
    else if (0 != (hv_GenParamType==HTuple("object")))
    {
      GetMessageObj(&ho_ObjectData, hv_MessageHandle, HTuple(hv_GenParamNames[hv_Index]));
      ConcatObj(ho_Objects, ho_ObjectData, &ho_Objects);
      if (HDevWindowStack::IsOpen())
        DispObj(ho_ObjectData, HDevWindowStack::GetActive());
    }
    else
    {
      //
    }
  }
  }
  // stop(); only in hdevelop
  //检测或训练
  //
  if (0 != (hv_IsTain==0))
  {
    //
    //
    ListFiles(hv_ImagePath, ((HTuple("files").Append("follow_links")).Append("recursive")), 
        &hv_ImageFiles);
    OpenFile(((hv_ImagePath+"/")+hv_TestName)+"检测数据.csv", "output", &hv_FileHandle);
    //close_file (FileHandle)
    TupleRegexpSelect(hv_ImageFiles, (HTuple("\\.(tif|tiff|gif|bmp|jpg|jpeg|jp2|png|pcx|pgm|ppm|pbm|xwd|ima|hobj)$").Append("ignore_case")), 
        &hv_ImageFiles);
    //
    {
    HTuple end_val46 = (hv_ImageFiles.TupleLength())-1;
    HTuple step_val46 = 1;
    for (hv_IndexSN=0; hv_IndexSN.Continue(end_val46, step_val46); hv_IndexSN += step_val46)
    {
      ReadImage(&ho_Image, HTuple(hv_ImageFiles[hv_IndexSN]));
      hvec_sssssssssss = (HTupleVector(2).Insert(0,HTupleVector(1)));
      hvec_sssssssssss.Insert(0,(HTupleVector(1).Insert(0,HTupleVector(HTuple()))));
      //
      //预处理
      CountSeconds(&hv_Seconds1);
      //
      HCheck(ho_Image, &ho_PreprocessImage, hv_IndexSN, 1, hv_WindowHandle, hv_MessageHandle, 
          &hv_ResultInfo, &hv_outLogInfo, &hvec_FeatureValss);

      //

      CountSeconds(&hv_Seconds2);
      // stop(); only in hdevelop
      //tuple_string (outLogInfo, '#', outLogInfo)
      //logtxt := sum(outLogInfo)
      //tuple_regexp_replace (ImageFiles[IndexSN], ImagePath, '', Result1)
      //fwrite_string (FileHandle, ImageFiles[IndexSN]+',')
      //fwrite_string (FileHandle, '检测时间：'+(Seconds2-Seconds1))
      //fwrite_string (FileHandle, logtxt)
      //get_image_size (PreprocessImage, Width, Height)
      //disp_message (WindowHandle, ImageFiles[IndexSN], 'image', Height-100, 0, 'black', 'true')
      //
      //parse_filename (ImageFiles[IndexSN], BaseName, Extension, Directory)
      //tuple_regexp_replace (Directory, ImagePath+'/', '', Result3)
      //tuple_split (Result3, '/', Substrings1)
      //
      //savepath := ImagePath+'Test/'+TestName+'/'+ResultInfo
      //tuple_split (savepath, '/', Substrings)
      //create_nodes (Substrings, Path)
      //savefile := Path+BaseName+'.'+Extension
      //dump_window_image (dumpImage, WindowHandle)
      //write_image (dumpImage, Extension, 0, savefile)
      //fwrite_string (FileHandle, ','+savefile)
      //
      //fnew_line (FileHandle)
      //
    }
    }
    CloseFile(hv_FileHandle);
  }
  // stop(); only in hdevelop
  ReadImage(&ho_Image1, "D:/cyw/0717img/实时图像6/MV-2E121MCQ1825A6-20191717-3-5-本体不良_20190717100850_4568770_176_16");
  CountSeconds(&hv_Seconds1);
  PreprocessImage(ho_Image1, &ho_PreprocessImage, hv_MessageHandle);
  DispImage(ho_PreprocessImage, hv_WindowHandle);
  hvec_adsa = (HTupleVector(1).Insert(0,HTupleVector(HTuple())));
  try
  {
    HCheck(ho_PreprocessImage, &ho_PreprocessImage2, hv_IndexSN, 1, hv_WindowHandle, 
        hv_MessageHandle, &hv_ResultInfo, &hv_outLogInfo, &hvec_FeatureValss1);
  }
  // catch (Exception) 
  catch (HalconCpp::HException &HDevExpDefaultException)
  {
    HDevExpDefaultException.ToHTuple(&hv_Exception);
    hv_ResultInfo = "Error";
    hv_outLogInfo = hv_Exception;
  }
  CountSeconds(&hv_Seconds2);
  // stop(); only in hdevelop
  if (0 != hv_IsTain)
  {
    //
    TrainTestSvm(1, hv_WindowHandle, hv_MessageHandle, hv_MessageHandle);
    //
    //
    //TrainNewModel (MessageHandle, WindowHandle, ClassNames, ImagePaths)
    //
    //
  }
  //
  // stop(); only in hdevelop
  //
  //关闭
  CloseCheck(hv_MessageHandle);
  //
  //
  //
  hv_str[0] = "Circle(200,200,100)";
  hv_str[1] = "circle_arc(200,200,100.5,0,3.14159)";
  hv_str[2] = "ellipse(200, 200, 0, 100, 60)";
  hv_str[3] = "ellipse_arc(200, 200, 0, 100, 60, 0, 3.14159)";
  hv_str[4] = "line(100,100,200,200)";
  hv_str[5] = "rectangle1(0,0,200,200)";
  hv_str[6] = "rectangle2(300, 200, 0, 100, 20)";
  //
  hv_DrawIDs = HTuple();
  hv_Params = HTuple();
  {
  HTuple end_val127 = (hv_str.TupleLength())-1;
  HTuple step_val127 = 1;
  for (hv_Index=0; hv_Index.Continue(end_val127, step_val127); hv_Index += step_val127)
  {
    create_object_drawID(HTuple(hv_str[hv_Index]), &hv_DrawID);
    hv_DrawIDs = hv_DrawIDs.TupleConcat(hv_DrawID);
    get_param_by_drawID(hv_DrawID, &hv_ParamType, &hv_Paramstr, &hv_ParamNote, &hv_ParamData);
    hv_Params = hv_Params.TupleConcat(hv_Paramstr);
  }
  }
  hv_Resultstrs.Clear();
  hv_Resultstrs[0] = "ok";
  hv_Resultstrs[1] = "dsad";
  hv_Resultstrs[2] = "dasdas";
  hv_Resultstrs[3] = "dsad";
  hv_Resultstrs[4] = "dasdas";
  hv_Resultstrs[5] = "";
  hv_Resultstrs[6] = "dasdas";
  hv_Resultstrs[7] = "ok";
  GetResult(hv_Resultstrs, &hv_ResultName, &hv_Resultstrs2);
  //
  //load_config_ValByType (TestPlanPath, CheckParam, 'CircleMax', 'circle', '1019,1386,568', CircleMaxstr)
  //gen_region_byTypeAndStr (CircleMax, 'circle', CircleMaxstr, vals)
  //set_message_obj (CircleMax, MessageHandle, 'CircleMax')
  //gen_region_by_str (Region, str, Type)
  //
  SaveImage(ho_Image, "21321.jpg");
  //
  get_message_tuple_romove(hv_MessageHandle, "Result"+hv_IndexSN, &hv_TupleData);
  //
  //
  //
  hv_Format = "jpg";
  hv_fillcolor = 0;
  hv_filename = "t";
  SaveImageThread(ho_Image, hv_Format, hv_fillcolor, hv_filename);
  //

  return;
}

// Generated stubs for parallel procedure calls. Wrapped in name
// space to avoid name conflicts with actual procedure names
namespace HDevExportCpp
{
// Parallel execution wrapper for Py_Memory_Check(...) 
static void* _hcppthread_Py_Memory_Check(void *hcthread)
{
  // +++ define thread context for this procedure
  HDevThread*  hcppthread = (HDevThread*) hcthread;
  try
  {
    // Input parameters
    const HObject       &cbho_Image = hcppthread->GetInputIconicParamObject(0);
    const HTuple        &cbhv_MessageHandle = hcppthread->GetInputCtrlParamTuple(1);
    const HTuple        &cbhv_WindowHandle = hcppthread->GetInputCtrlParamTuple(2);
    const HTuple        &cbhv_ShowHide = hcppthread->GetInputCtrlParamTuple(3);
    const HTuple        &cbhv_Width = hcppthread->GetInputCtrlParamTuple(4);
    const HTuple        &cbhv_Height = hcppthread->GetInputCtrlParamTuple(5);
    const HTuple        &cbhv_ImageInfos = hcppthread->GetInputCtrlParamTuple(6);

    // Output parameters
    HObject       cbho_ImageResult;
    HTuple        cbhv_ResultVal;

    // Call Py_Memory_Check
    Py_Memory_Check(cbho_Image, &cbho_ImageResult, cbhv_MessageHandle, cbhv_WindowHandle, 
        cbhv_ShowHide, cbhv_Width, cbhv_Height, cbhv_ImageInfos, &cbhv_ResultVal);

    // Store output parameters in thread object
    hcppthread->StoreOutputIconicParamObject(0,cbho_ImageResult);
    hcppthread->StoreOutputCtrlParamTuple(1,cbhv_ResultVal);

    // Reduce reference counter of thread object
    hcppthread->Exit();
    delete hcppthread;

  }
  catch (HException& exc)
  {
    // No exceptions may be raised from stub in parallel case,
    // so we need to store this information prior to cleanup
    bool is_direct_call = hcppthread->IsDirectCall();
    // Attempt to clean up in error case, too
    hcppthread->Exit();
    delete hcppthread;
    // Propagate exception if called directly
    if (is_direct_call)
      throw exc;
  }
  return NULL;
}

// Parallel execution wrapper for write_image(...) 
static void* _hcppthread_write_image(void *hcthread)
{
  // +++ define thread context for this procedure
  HDevThread*  hcppthread = (HDevThread*) hcthread;
  try
  {
    // Input parameters
    const HObject       &cbho_Image = hcppthread->GetInputIconicParamObject(0);
    const HTuple        &cbhv_Format = hcppthread->GetInputCtrlParamTuple(1);
    const HTuple        &cbhv_FillColor = hcppthread->GetInputCtrlParamTuple(2);
    const HTuple        &cbhv_FileName = hcppthread->GetInputCtrlParamTuple(3);

    // Call write_image
    WriteImage(cbho_Image, cbhv_Format, cbhv_FillColor, cbhv_FileName);

    // Reduce reference counter of thread object
    hcppthread->Exit();
    delete hcppthread;

  }
  catch (HException& exc)
  {
    // No exceptions may be raised from stub in parallel case,
    // so we need to store this information prior to cleanup
    bool is_direct_call = hcppthread->IsDirectCall();
    // Attempt to clean up in error case, too
    hcppthread->Exit();
    delete hcppthread;
    // Propagate exception if called directly
    if (is_direct_call)
      throw exc;
  }
  return NULL;
}

}


